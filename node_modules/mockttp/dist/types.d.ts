/**
 * @module Internal
 */
/// <reference types="node" />
import stream = require('stream');
import http = require('http');
import { EventEmitter } from 'events';
export declare const DEFAULT_STANDALONE_PORT = 45454;
export declare enum Method {
    GET = 0,
    POST = 1,
    PUT = 2,
    DELETE = 3,
    PATCH = 4,
    HEAD = 5,
    OPTIONS = 6
}
export interface Headers {
    host?: string;
    'content-length'?: string;
    'content-type'?: string;
    'user-agent'?: string;
    cookie?: string;
    ':method'?: string;
    ':scheme'?: string;
    ':authority'?: string;
    ':path'?: string;
    [key: string]: undefined | string | string[];
}
export interface Request {
    id: string;
    matchedRuleId?: string;
    protocol: string;
    httpVersion?: string;
    method: string;
    url: string;
    path: string;
    hostname?: string;
    headers: Headers;
    timingEvents: TimingEvents | {};
    tags: string[];
}
export interface TlsRequest {
    hostname?: string;
    remoteIpAddress: string;
    remotePort: number;
    failureCause: 'closed' | 'reset' | 'cert-rejected' | 'no-shared-cipher' | 'unknown';
    tags: string[];
    timingEvents: TlsTimingEvents;
}
export interface TlsTimingEvents {
    startTime: number;
    connectTimestamp: number;
    failureTimestamp: number;
    handshakeTimestamp?: number;
    tunnelTimestamp?: number;
}
export interface OngoingRequest extends Request, EventEmitter {
    body: ParsedBody;
    timingEvents: TimingEvents;
}
export interface ParsedBody {
    asStream: () => stream.Readable;
    asBuffer: () => Promise<Buffer>;
    asText: () => Promise<string>;
    asJson: () => Promise<object>;
    asFormData: () => Promise<{
        [key: string]: string | string[];
    }>;
}
export interface CompletedBody {
    buffer: Buffer;
    decodedBuffer: Buffer | undefined;
    text: string | undefined;
    json: object | undefined;
    formData: {
        [key: string]: string | string[];
    } | undefined;
}
export interface InitiatedRequest extends Request {
    timingEvents: TimingEvents;
}
export interface CompletedRequest extends Request {
    body: CompletedBody;
}
export interface TimingEvents {
    startTime: number;
    startTimestamp: number;
    bodyReceivedTimestamp?: number;
    headersSentTimestamp?: number;
    responseSentTimestamp?: number;
    abortedTimestamp?: number;
}
export interface OngoingResponse extends http.ServerResponse {
    id: string;
    getHeaders(): Headers;
    body: ParsedBody;
    timingEvents: TimingEvents;
    tags: string[];
}
export interface CompletedResponse {
    id: string;
    statusCode: number;
    statusMessage: string;
    headers: Headers;
    body: CompletedBody;
    timingEvents: TimingEvents | {};
    tags: string[];
}
/**
 * A client error event describes a request (or our best guess at parsing it),
 * that wasn't correctly completed, and the error response it received, or
 * 'aborted' if the connection was disconnected before we could respond.
 */
export interface ClientError {
    errorCode?: string;
    request: {
        id: string;
        timingEvents: TimingEvents;
        tags: string[];
        protocol?: string;
        httpVersion?: string;
        method?: string;
        url?: string;
        path?: string;
        headers: Headers;
    };
    response: CompletedResponse | 'aborted';
}
/**
 * A mocked endpoint provides methods to see the current state of
 * a mock rule.
 */
export interface MockedEndpoint {
    id: string;
    /**
     * Get the requests that this endpoint has seen so far.
     *
     * This method returns a promise, which resolves with the requests seen
     * up until now, once all ongoing requests have terminated. The returned
     * lists are immutable, so won't change if more requests arrive in future.
     * Call `getSeenRequests` again later to get an updated list.
     */
    getSeenRequests(): Promise<CompletedRequest[]>;
    /**
     * Reports whether this endpoint is still pending: if it either hasn't seen the
     * specified number of requests (if one was specified e.g. with .twice())
     * or if it hasn't seen at least one request, by default.
     *
     * This method returns a promise, which resolves with the result once all
     * ongoing requests have terminated.
     */
    isPending(): Promise<boolean>;
}
export interface MockedEndpointData {
    id: string;
    explanation?: string;
    seenRequests: CompletedRequest[];
    isPending: boolean;
}
export interface Explainable {
    explain(): string;
}
export interface ProxyConfig {
    HTTP_PROXY: string;
    HTTPS_PROXY: string;
}
