/**
 * @module MockRule
 */
/// <reference types="node" />
import { Readable } from 'stream';
import { TypedError } from 'typed-error';
import { Serializable, ClientServerChannel } from "../../util/serialization";
import { MaybePromise } from '../../util/type-utils';
import { Headers, OngoingRequest, CompletedRequest, OngoingResponse, CompletedBody, Explainable } from "../../types";
export declare class AbortError extends TypedError {
}
export declare type SerializedBuffer = {
    type: 'Buffer';
    data: number[];
};
export interface CallbackRequestResult {
    method?: string;
    url?: string;
    headers?: Headers;
    json?: any;
    body?: string | Buffer;
    response?: CallbackResponseResult;
}
export interface CallbackResponseResult {
    statusCode?: number;
    status?: number;
    statusMessage?: string;
    headers?: Headers;
    json?: any;
    body?: string | Buffer;
}
export interface RequestHandler extends Explainable, Serializable {
    type: keyof typeof HandlerLookup;
    handle(request: OngoingRequest, response: OngoingResponse): Promise<void>;
}
export declare class SimpleHandler extends Serializable implements RequestHandler {
    status: number;
    statusMessage?: string | undefined;
    data?: string | Buffer | SerializedBuffer | undefined;
    headers?: Headers | undefined;
    readonly type = "simple";
    constructor(status: number, statusMessage?: string | undefined, data?: string | Buffer | SerializedBuffer | undefined, headers?: Headers | undefined);
    explain(): string;
    handle(_request: OngoingRequest, response: OngoingResponse): Promise<void>;
}
export interface SerializedCallbackHandlerData {
    type: string;
    name?: string;
}
export declare class CallbackHandler extends Serializable implements RequestHandler {
    callback: (request: CompletedRequest) => MaybePromise<CallbackResponseResult>;
    readonly type = "callback";
    constructor(callback: (request: CompletedRequest) => MaybePromise<CallbackResponseResult>);
    explain(): string;
    handle(request: OngoingRequest, response: OngoingResponse): Promise<void>;
    serialize(channel: ClientServerChannel): SerializedCallbackHandlerData;
    static deserialize({ name }: SerializedCallbackHandlerData, channel: ClientServerChannel): CallbackHandler;
}
export interface SerializedStreamHandlerData {
    type: string;
    status: number;
    headers?: Headers;
}
export declare class StreamHandler extends Serializable implements RequestHandler {
    status: number;
    stream: Readable & {
        done?: true;
    };
    headers?: Headers | undefined;
    readonly type = "stream";
    constructor(status: number, stream: Readable & {
        done?: true;
    }, headers?: Headers | undefined);
    explain(): string;
    handle(_request: OngoingRequest, response: OngoingResponse): Promise<void>;
    serialize(channel: ClientServerChannel): SerializedStreamHandlerData;
    static deserialize(handlerData: SerializedStreamHandlerData, channel: ClientServerChannel): StreamHandler;
}
export declare class FileHandler extends Serializable implements RequestHandler {
    status: number;
    statusMessage: string | undefined;
    filePath: string;
    headers?: Headers | undefined;
    readonly type = "file";
    constructor(status: number, statusMessage: string | undefined, filePath: string, headers?: Headers | undefined);
    explain(): string;
    handle(_request: OngoingRequest, response: OngoingResponse): Promise<void>;
}
export interface PassThroughResponse {
    id: string;
    statusCode: number;
    statusMessage?: string;
    headers: Headers;
    body: CompletedBody;
}
export interface ForwardingOptions {
    targetHost: string;
    updateHostHeader?: true | false | string;
}
export interface PassThroughLookupOptions {
    /**
     * The maximum time to cache a DNS response. Up to this limit,
     * responses will be cached according to their own TTL. Defaults
     * to Infinity.
     */
    maxTtl?: number;
    /**
     * How long to cache a DNS ENODATA or ENOTFOUND response. Defaults
     * to 0.15.
     */
    errorTtl?: number;
    /**
     * The primary servers to use. DNS queries will be resolved against
     * these servers first. If no data is available, queries will fall
     * back to dns.lookup, and use the OS's default DNS servers.
     *
     * This defaults to dns.getServers().
     */
    servers?: string[];
}
export interface PassThroughHandlerOptions {
    /**
     * The forwarding configuration for the passthrough rule.
     * This generally shouldn't be used explicitly unless you're
     * building rule data by hand. Instead, call `thenPassThrough`
     * to send data directly or `thenForwardTo` with options to
     * configure traffic forwarding.
     */
    forwarding?: ForwardingOptions;
    /**
     * A list of hostnames for which server certificate errors should be ignored
     * (none, by default).
     */
    ignoreHostCertificateErrors?: string[];
    /**
     * A mapping of hosts to client certificates to use, in the form of
     * `{ key, cert }` objects (none, by default)
     */
    clientCertificateHostMap?: {
        [host: string]: {
            pfx: Buffer;
            passphrase?: string;
        };
    };
    /**
     * Custom DNS options, to allow configuration of the resolver used
     * when forwarding requests upstream. Passing any option switches
     * from using node's default dns.lookup function to using the
     * cacheable-lookup module, which will cache responses.
     */
    lookupOptions?: PassThroughLookupOptions;
    /**
     * A callback that will be passed the full request before it is passed through,
     * and which returns an object that defines how the the request content should
     * be changed before it's passed to the upstream server.
     *
     * The callback should return an object that definies how the request
     * should be changed. All fields on the object are optional. The possible
     * fields are:
     *
     * - `method` (a replacement HTTP verb, capitalized)
     * - `url` (a full URL to send the request to)
     * - `response` (a response callback result: if provided this will be used
     *   directly, the request will not be passed through at all, and any
     *   beforeResponse callback will never fire)
     * - `headers` (object with string keys & values, replaces all headers if set)
     * - `body` (string or buffer, replaces the body if set)
     * - `json` (object, to be sent as a JSON-encoded body, taking precedence
     *   over `body` if both are set)
     */
    beforeRequest?: (req: CompletedRequest) => MaybePromise<CallbackRequestResult>;
    /**
     * A callback that will be passed the full response before it is passed through,
     * and which returns an object that defines how the the response content should
     * before it's returned to the client.
     *
     * The callback should return an object that definies how the response
     * should be changed. All fields on the object are optional. The possible
     * fields are:
     *
     * - `status` (number, will replace the HTTP status code)
     * - `headers` (object with string keys & values, replaces all headers if set)
     * - `body` (string or buffer, replaces the body if set)
     * - `json` (object, to be sent as a JSON-encoded body, taking precedence
     *   over `body` if both are set)
     */
    beforeResponse?: (res: PassThroughResponse) => MaybePromise<CallbackResponseResult>;
}
interface SerializedPassThroughData {
    type: 'passthrough';
    forwardToLocation?: string;
    forwarding?: ForwardingOptions;
    ignoreHostCertificateErrors?: string[];
    clientCertificateHostMap?: {
        [host: string]: {
            pfx: string;
            passphrase?: string;
        };
    };
    lookupOptions?: PassThroughLookupOptions;
    hasBeforeRequestCallback?: boolean;
    hasBeforeResponseCallback?: boolean;
}
export declare class PassThroughHandler extends Serializable implements RequestHandler {
    readonly type = "passthrough";
    readonly forwarding?: ForwardingOptions;
    readonly ignoreHostCertificateErrors: string[];
    readonly clientCertificateHostMap: {
        [host: string]: {
            pfx: Buffer;
            passphrase?: string;
        };
    };
    readonly beforeRequest?: (req: CompletedRequest) => MaybePromise<CallbackRequestResult>;
    readonly beforeResponse?: (res: PassThroughResponse) => MaybePromise<CallbackResponseResult>;
    readonly lookupOptions: PassThroughLookupOptions | undefined;
    private _cacheableLookupInstance;
    private lookup;
    constructor(options?: PassThroughHandlerOptions);
    explain(): string;
    handle(clientReq: OngoingRequest, clientRes: OngoingResponse): Promise<void>;
    serialize(channel: ClientServerChannel): SerializedPassThroughData;
    static deserialize(data: SerializedPassThroughData, channel: ClientServerChannel): PassThroughHandler;
}
export declare class CloseConnectionHandler extends Serializable implements RequestHandler {
    readonly type = "close-connection";
    explain(): string;
    handle(request: OngoingRequest): Promise<void>;
}
export declare class TimeoutHandler extends Serializable implements RequestHandler {
    readonly type = "timeout";
    explain(): string;
    handle(): Promise<void>;
}
export declare const HandlerLookup: {
    'simple': typeof SimpleHandler;
    'callback': typeof CallbackHandler;
    'stream': typeof StreamHandler;
    'file': typeof FileHandler;
    'passthrough': typeof PassThroughHandler;
    'close-connection': typeof CloseConnectionHandler;
    'timeout': typeof TimeoutHandler;
};
export {};
