"use strict";
/**
 * @module MockWebsocketRule
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const uuid = require("uuid/v4");
const request_utils_1 = require("../../util/request-utils");
const matchers = require("../matchers");
const rule_serialization_1 = require("../rule-serialization");
class WebSocketRule {
    constructor(data) {
        this.requests = [];
        this.requestCount = 0;
        rule_serialization_1.validateMockRuleData(data);
        this.id = data.id || uuid();
        this.matchers = data.matchers;
        this.handler = data.handler;
        this.completionChecker = data.completionChecker;
    }
    matches(request) {
        return matchers.matchesAll(request, this.matchers);
    }
    handle(req, res, head, record) {
        let completedPromise = (() => __awaiter(this, void 0, void 0, function* () {
            yield this.handler.handle(req, res, head);
            return request_utils_1.waitForCompletedRequest(req);
        }))();
        // Requests are added to rule.requests as soon as they start being handled,
        // as promises, which resolve when the response is complete.
        if (record) {
            this.requests.push(completedPromise);
        }
        // Even if traffic recording is disabled, the number of matched
        // requests is still tracked
        this.requestCount += 1;
        return completedPromise;
    }
    isComplete() {
        if (this.completionChecker) {
            // If we have a specific rule, use that
            return this.completionChecker.isComplete(this.requestCount);
        }
        else if (this.requestCount === 0) {
            // Otherwise, by default we're definitely incomplete if we've seen no requests
            return false;
        }
        else {
            // And we're _maybe_ complete if we've seen at least one request. In reality, we're incomplete
            // but we should be used anyway if we're at any point we're the last matching rule for a request.
            return null;
        }
    }
    explain(withoutExactCompletion = false) {
        let explanation = `Match websockets ${matchers.explainMatchers(this.matchers)}, ` +
            `and then ${this.handler.explain()}`;
        if (this.completionChecker) {
            explanation += `, ${this.completionChecker.explain(withoutExactCompletion ? undefined : this.requestCount)}.`;
        }
        else {
            explanation += '.';
        }
        return explanation;
    }
    dispose() {
        this.handler.dispose();
        this.matchers.forEach(m => m.dispose());
        if (this.completionChecker)
            this.completionChecker.dispose();
    }
}
exports.WebSocketRule = WebSocketRule;
//# sourceMappingURL=websocket-rule.js.map