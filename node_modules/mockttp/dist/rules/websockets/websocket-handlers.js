"use strict";
/**
 * @module MockWebsocketRule
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const _ = require("lodash");
const url = require("url");
const WebSocket = require("ws");
const common_tags_1 = require("common-tags");
const cacheable_lookup_1 = require("cacheable-lookup");
const serialization_1 = require("../../util/serialization");
const request_handlers_1 = require("../requests/request-handlers");
exports.CloseConnectionHandler = request_handlers_1.CloseConnectionHandler;
exports.TimeoutHandler = request_handlers_1.TimeoutHandler;
const request_utils_1 = require("../../util/request-utils");
function isOpen(socket) {
    return socket.readyState === WebSocket.OPEN;
}
function pipeWebSocket(inSocket, outSocket) {
    const onPipeFailed = (op) => (err) => {
        if (!err)
            return;
        inSocket.close();
        console.error(`Websocket ${op} failed`, err);
    };
    inSocket.on('message', (msg) => {
        if (isOpen(outSocket)) {
            outSocket.send(msg, onPipeFailed('message'));
        }
    });
    inSocket.on('close', (num, reason) => {
        if (num >= 1000 && num <= 1004) {
            outSocket.close(num, reason);
        }
        else {
            console.log(`Unhappily closing websocket ${num}: ${reason}`);
            // Unspecified or invalid error
            outSocket.close();
        }
    });
    inSocket.on('ping', (data) => {
        if (isOpen(outSocket))
            outSocket.ping(data, undefined, onPipeFailed('ping'));
    });
    inSocket.on('pong', (data) => {
        if (isOpen(outSocket))
            outSocket.pong(data, undefined, onPipeFailed('pong'));
    });
}
function mirrorRejection(socket, rejectionResponse) {
    return __awaiter(this, void 0, void 0, function* () {
        if (socket.writable) {
            const { statusCode, statusMessage, headers } = rejectionResponse;
            socket.write(`HTTP/1.1 ${statusCode} ${statusMessage}\r\n` +
                _.map(headers, (value, key) => `${key}: ${value}`).join('\r\n') +
                '\r\n\r\n');
            const body = yield request_utils_1.streamToBuffer(rejectionResponse);
            if (socket.writable)
                socket.write(body);
        }
        socket.destroy();
    });
}
class PassThroughWebSocketHandler extends serialization_1.Serializable {
    constructor(options = {}) {
        super();
        this.type = 'ws-passthrough';
        this.ignoreHostCertificateErrors = [];
        this.ignoreHostCertificateErrors = options.ignoreHostCertificateErrors || [];
        if (!Array.isArray(this.ignoreHostCertificateErrors)) {
            throw new Error("ignoreHostCertificateErrors must be an array");
        }
        // If a location is provided, and it's not a bare hostname, it must be parseable
        const { forwarding } = options;
        if (forwarding && forwarding.targetHost.includes('/')) {
            const { protocol, hostname, port, path } = url.parse(forwarding.targetHost);
            if (path && path.trim() !== "/") {
                const suggestion = url.format({ protocol, hostname, port }) ||
                    forwarding.targetHost.slice(0, forwarding.targetHost.indexOf('/'));
                throw new Error(common_tags_1.stripIndent `
                    URLs for forwarding cannot include a path, but "${forwarding.targetHost}" does. ${''}Did you mean ${suggestion}?
                `);
            }
        }
        this.forwarding = options.forwarding;
        this.lookupOptions = options.lookupOptions;
    }
    lookup() {
        if (!this.lookupOptions)
            return undefined;
        if (!this._cacheableLookupInstance) {
            this._cacheableLookupInstance = new cacheable_lookup_1.default({
                maxTtl: this.lookupOptions.maxTtl,
                errorTtl: this.lookupOptions.errorTtl,
                // As little caching of "use the fallback server" as possible:
                fallbackDuration: 1
            });
            if (this.lookupOptions.servers) {
                this._cacheableLookupInstance.servers = this.lookupOptions.servers;
            }
        }
        return this._cacheableLookupInstance.lookup;
    }
    explain() {
        return this.forwarding
            ? `forward the websocket to ${this.forwarding.targetHost}`
            : 'pass the request through to the target host';
    }
    initializeWsServer() {
        if (this.wsServer)
            return;
        this.wsServer = new WebSocket.Server({ noServer: true });
        this.wsServer.on('connection', (ws) => {
            pipeWebSocket(ws, ws.upstreamSocket);
            pipeWebSocket(ws.upstreamSocket, ws);
        });
    }
    handle(req, socket, head) {
        return __awaiter(this, void 0, void 0, function* () {
            this.initializeWsServer();
            let { protocol, hostname, port, path } = url.parse(req.url);
            const headers = req.headers;
            const reqMessage = req;
            const isH2Downstream = request_utils_1.isHttp2(req);
            const hostHeaderName = isH2Downstream ? ':authority' : 'host';
            if (this.forwarding) {
                const { targetHost, updateHostHeader } = this.forwarding;
                let wsUrl;
                if (!targetHost.includes('/')) {
                    // We're forwarding to a bare hostname, just overwrite that bit:
                    [hostname, port] = targetHost.split(':');
                }
                else {
                    // Forwarding to a full URL; override the host & protocol, but never the path.
                    ({ protocol, hostname, port } = url.parse(targetHost));
                }
                // Connect directly to the forwarding target URL
                wsUrl = `${protocol.replace('http', 'ws')}//${hostname}${port ? ':' + port : ''}${path}`;
                // Optionally update the host header too:
                if (updateHostHeader === undefined || updateHostHeader === true) {
                    // If updateHostHeader is true, or just not specified, match the new target
                    headers[hostHeaderName] = hostname + (port ? `:${port}` : '');
                }
                else if (updateHostHeader) {
                    // If it's an explicit custom value, use that directly.
                    headers[hostHeaderName] = updateHostHeader;
                } // Otherwise: falsey means don't touch it.
                this.connectUpstream(wsUrl, reqMessage, headers, socket, head);
            }
            else if (!hostname) { // No hostname in URL means transparent proxy, so use Host header
                const hostHeader = req.headers[hostHeaderName];
                [hostname, port] = hostHeader.split(':');
                // lastHopEncrypted is set in http-combo-server, for requests that have explicitly
                // CONNECTed upstream (which may then up/downgrade from the current encryption).
                if (socket.lastHopEncrypted !== undefined) {
                    protocol = socket.lastHopEncrypted ? 'wss' : 'ws';
                }
                else {
                    protocol = reqMessage.connection.encrypted ? 'wss' : 'ws';
                }
                const wsUrl = `${protocol}://${hostname}${port ? ':' + port : ''}${path}`;
                this.connectUpstream(wsUrl, reqMessage, headers, socket, head);
            }
            else {
                // Connect directly according to the specified URL
                const wsUrl = `${protocol.replace('http', 'ws')}//${hostname}${port ? ':' + port : ''}${path}`;
                this.connectUpstream(wsUrl, reqMessage, headers, socket, head);
            }
        });
    }
    connectUpstream(wsUrl, req, headers, incomingSocket, head) {
        // Initialize the server when we handle the first actual request. Mainly just so we
        // don't try to initialize it in a browser when buiding rules initially.
        if (!this.wsServer)
            this.wsServer = new WebSocket.Server({ noServer: true });
        // Skip cert checks if the host or host+port are whitelisted
        const parsedUrl = url.parse(wsUrl);
        const checkServerCertificate = !_.includes(this.ignoreHostCertificateErrors, parsedUrl.hostname) &&
            !_.includes(this.ignoreHostCertificateErrors, parsedUrl.host);
        const upstreamSocket = new WebSocket(wsUrl, {
            rejectUnauthorized: checkServerCertificate,
            maxPayload: 0,
            lookup: this.lookup(),
            headers: _.omitBy(headers, (_v, headerName) => headerName.toLowerCase().startsWith('sec-websocket') ||
                headerName.toLowerCase() === 'connection') // Simplify to string - doesn't matter though, only used by http module anyway
        });
        upstreamSocket.once('open', () => {
            // Presumably the below adds an error handler. But what about before we get here?
            this.wsServer.handleUpgrade(req, incomingSocket, head, (ws) => {
                ws.upstreamSocket = upstreamSocket;
                this.wsServer.emit('connection', ws);
            });
        });
        // If the upstream says no, we say no too.
        upstreamSocket.on('unexpected-response', (req, res) => {
            console.log(`Unexpected websocket response from ${wsUrl}: ${res.statusCode}`);
            mirrorRejection(incomingSocket, res);
        });
        // If there's some other error, we just kill the socket:
        upstreamSocket.on('error', (e) => {
            console.warn(e);
            incomingSocket.end();
        });
        incomingSocket.on('error', () => upstreamSocket.close(1011)); // Internal error
    }
}
exports.PassThroughWebSocketHandler = PassThroughWebSocketHandler;
exports.WsHandlerLookup = {
    'ws-passthrough': PassThroughWebSocketHandler,
    'close-connection': request_handlers_1.CloseConnectionHandler,
    'timeout': request_handlers_1.TimeoutHandler
};
//# sourceMappingURL=websocket-handlers.js.map