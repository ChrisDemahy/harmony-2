"use strict";
/**
 * @module Mockttp
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const typed_error_1 = require("typed-error");
const getFetchPonyfill = require("fetch-ponyfill");
const _ = require("lodash");
const WebSocket = require("universal-websocket-client");
const connectWebSocketStream = require("websocket-stream");
const subscriptions_transport_ws_1 = require("subscriptions-transport-ws");
const { 
/** @hidden */
fetch, 
/** @hidden */
Headers } = getFetchPonyfill();
const mockttp_1 = require("../mockttp");
const rule_serialization_1 = require("../rules/rule-serialization");
const types_1 = require("../types");
const mocked_endpoint_client_1 = require("./mocked-endpoint-client");
const request_utils_1 = require("../util/request-utils");
const introspection_query_1 = require("./introspection-query");
class ConnectionError extends typed_error_1.TypedError {
}
exports.ConnectionError = ConnectionError;
class RequestError extends typed_error_1.TypedError {
    constructor(message, response) {
        super(message);
        this.response = response;
    }
}
exports.RequestError = RequestError;
class GraphQLError extends RequestError {
    constructor(response, errors) {
        super(`GraphQL request failed, with errors:\n${errors.map((e) => e.message).join('\n')}`, response);
        this.errors = errors;
    }
}
exports.GraphQLError = GraphQLError;
const mergeClientOptions = (options, defaultOptions) => {
    if (!defaultOptions)
        return options;
    if (!options)
        return defaultOptions;
    if (defaultOptions.headers) {
        if (!options.headers) {
            options.headers = defaultOptions.headers;
        }
        else if (options.headers instanceof Headers) {
            _.forEach(defaultOptions.headers, (value, key) => {
                options.headers.append(key, value);
            });
        }
        else if (_.isObject(options.headers)) {
            Object.assign(options.headers, defaultOptions.headers);
        }
    }
    return options;
};
function normalizeHttpMessage(event, message) {
    if (message.timingEvents) {
        // Timing events are serialized as raw JSON
        message.timingEvents = JSON.parse(message.timingEvents);
    }
    else if (event !== 'tls-client-error' && event !== 'client-error') {
        // For backwards compat, all except errors should have timing events if they're missing
        message.timingEvents = {};
    }
    if (message.headers) {
        message.headers = JSON.parse(message.headers);
    }
    if (message.body) {
        // Body is serialized as the raw encoded buffer in base64
        message.body = request_utils_1.buildBodyReader(Buffer.from(message.body, 'base64'), message.headers);
    }
    // For backwards compat, all except errors should have tags if they're missing
    if (!message.tags)
        message.tags = [];
}
/**
 * A Mockttp implementation, controlling a remote Mockttp standalone server.
 *
 * This starts servers by making requests to the remote standalone server, and exposes
 * methods to directly manage them.
 */
class MockttpClient extends mockttp_1.AbstractMockttp {
    constructor(options = {}) {
        super(_.defaults(options, {
            // Browser clients generally want cors enabled. For other clients, it doesn't hurt.
            // TODO: Maybe detect whether we're in a browser in future
            cors: true,
            standaloneServerUrl: `http://localhost:${types_1.DEFAULT_STANDALONE_PORT}`
        }));
        this.reset = () => __awaiter(this, void 0, void 0, function* () {
            return (yield this.queryMockServer(`mutation Reset {
                    reset
            }`));
        });
        this.addRequestRules = (...rules) => __awaiter(this, void 0, void 0, function* () {
            return this._addRules(rules, false);
        });
        this.setRequestRules = (...rules) => __awaiter(this, void 0, void 0, function* () {
            return this._addRules(rules, true);
        });
        this.addWebSocketRules = (...rules) => __awaiter(this, void 0, void 0, function* () {
            return this._addWsRules(rules, false);
        });
        this.setWebSocketRules = (...rules) => __awaiter(this, void 0, void 0, function* () {
            return this._addWsRules(rules, true);
        });
        this._addRules = (rules, reset) => __awaiter(this, void 0, void 0, function* () {
            if (!this.mockServerConfig)
                throw new Error('Cannot add rules before the server is started');
            // Backward compat: make Add/SetRules work with servers that only define reset & addRule (singular).
            // Adds a small risk of odd behaviour in the gap between reset & all the rules being added, but it
            // should be extremely brief, and no worse than existing behaviour for those server versions.
            if (!this.typeHasField('Mutation', 'addRules')) {
                if (reset)
                    yield this.reset();
                // Sequentially add the rules:
                return rules.reduce((acc, rule) => {
                    return acc.then((endpoints) => __awaiter(this, void 0, void 0, function* () {
                        endpoints.push(yield this._addRule(rule));
                        return endpoints;
                    }));
                }, Promise.resolve([]));
            }
            const requestName = reset ? 'SetRules' : 'AddRules';
            const mutationName = reset ? 'setRules' : 'addRules';
            let endpoints = (yield this.queryMockServer(`mutation ${requestName}($newRules: [MockRule!]!) {
                endpoints: ${mutationName}(input: $newRules) {
                    id,
                    ${this.optionalField('MockedEndpoint', 'explanation')}
                }
            }`, {
                newRules: rules.map((rule) => {
                    const serializedData = rule_serialization_1.serializeRuleData(rule, this.mockServerStream);
                    if (!this.typeHasInputField('MockRule', 'id')) {
                        delete serializedData.id;
                    }
                    return serializedData;
                })
            })).endpoints;
            return endpoints.map(({ id, explanation }) => new mocked_endpoint_client_1.MockedEndpointClient(id, explanation, this.getEndpointDataGetter(id)));
        });
        this._addWsRules = (rules, reset) => __awaiter(this, void 0, void 0, function* () {
            // Seperate and much simpler than _addRules, because it doesn't have to deal with
            // backward compatibility.
            if (!this.mockServerConfig)
                throw new Error('Cannot add rules before the server is started');
            const requestName = (reset ? 'Set' : 'Add') + 'WebSocketRules';
            const mutationName = (reset ? 'set' : 'add') + 'WebSocketRules';
            let endpoints = (yield this.queryMockServer(`mutation ${requestName}($newRules: [WebSocketMockRule!]!) {
                endpoints: ${mutationName}(input: $newRules) {
                    id,
                    explanation
                }
            }`, {
                newRules: rules.map((rule) => rule_serialization_1.serializeRuleData(rule, this.mockServerStream))
            })).endpoints;
            return endpoints.map(({ id, explanation }) => new mocked_endpoint_client_1.MockedEndpointClient(id, explanation, this.getEndpointDataGetter(id)));
        });
        // Exists purely for backward compat with servers that don't support AddRules/SetRules.
        this._addRule = (rule) => __awaiter(this, void 0, void 0, function* () {
            const ruleData = rule_serialization_1.serializeRuleData(rule, this.mockServerStream);
            delete ruleData.id; // Old servers don't support sending ids.
            const response = yield this.queryMockServer(`mutation AddRule($newRule: MockRule!) {
                addRule(input: $newRule) {
                    id,
                    ${this.optionalField('MockedEndpoint', 'explanation')}
                }
            }`, {
                newRule: ruleData
            });
            const mockedEndpoint = response.addRule;
            return new mocked_endpoint_client_1.MockedEndpointClient(mockedEndpoint.id, mockedEndpoint.explanation, this.getEndpointDataGetter(mockedEndpoint.id));
        });
        this.getEndpointDataGetter = (ruleId) => () => __awaiter(this, void 0, void 0, function* () {
            let result = yield this.queryMockServer(`query GetEndpointData($id: ID!) {
                mockedEndpoint(id: $id) {
                    seenRequests {
                        protocol,
                        method,
                        url,
                        path,
                        hostname,
                        headers,
                        body,
                        ${this.optionalField('Request', 'timingEvents')}
                        ${this.optionalField('Request', 'httpVersion')}
                    }
                    ${this.optionalField('MockedEndpoint', 'isPending')}
                }
            }`, {
                id: ruleId
            });
            const mockedEndpoint = result.mockedEndpoint;
            if (!mockedEndpoint)
                return null;
            mockedEndpoint.seenRequests.forEach((request) => {
                request.body = request_utils_1.buildBodyReader(Buffer.from(request.body, 'base64'), request.headers);
            });
            return mockedEndpoint;
        });
        // Note that 'defaults' above mutates this, so this includes
        // the default parameter values too (and thus the type assertion)
        this.mockServerOptions = _.omit(options, 'client');
        this.mockClientOptions = options.client || {};
    }
    requestFromStandalone(path, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = `${this.mockServerOptions.standaloneServerUrl}${path}`;
            let response;
            try {
                response = yield fetch(url, mergeClientOptions(options, this.mockClientOptions));
            }
            catch (e) {
                if (e.code === 'ECONNREFUSED') {
                    throw new ConnectionError(`Failed to connect to standalone server at ${this.mockServerOptions.standaloneServerUrl}`);
                }
                else
                    throw e;
            }
            if (response.status >= 400) {
                let body = yield response.text();
                let jsonBody = null;
                try {
                    jsonBody = JSON.parse(body);
                }
                catch (e) { }
                if (jsonBody && jsonBody.error) {
                    throw new RequestError(jsonBody.error, response);
                }
                else {
                    throw new RequestError(`Request to ${url} failed, with status ${response.status} and response body: ${body}`, response);
                }
            }
            else {
                return response.json();
            }
        });
    }
    openStreamToMockServer(config) {
        var _a;
        const standaloneStreamServer = this.mockServerOptions.standaloneServerUrl.replace(/^http/, 'ws');
        const stream = connectWebSocketStream(`${standaloneStreamServer}/server/${config.port}/stream`, {
            objectMode: true,
            headers: (_a = this.mockClientOptions) === null || _a === void 0 ? void 0 : _a.headers
        });
        return new Promise((resolve, reject) => {
            stream.once('connect', () => resolve(stream));
            stream.once('error', reject);
        });
    }
    requestFromMockServer(path, options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.mockServerConfig)
                throw new Error('Not connected to mock server');
            let url = `${this.mockServerOptions.standaloneServerUrl}/server/${this.mockServerConfig.port}${path}`;
            let response = yield fetch(url, mergeClientOptions(options, this.mockClientOptions));
            if (response.status >= 400) {
                throw new RequestError(`Request to ${url} failed, with status ${response.status}`, response);
            }
            else {
                return response;
            }
        });
    }
    queryMockServer(query, variables) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const response = (yield this.requestFromMockServer('/', {
                    method: 'POST',
                    headers: new Headers({
                        'Content-Type': 'application/json'
                    }),
                    body: JSON.stringify({ query, variables })
                }));
                const { data, errors } = yield response.json();
                if (errors && errors.length) {
                    throw new GraphQLError(response, errors);
                }
                else {
                    return data;
                }
            }
            catch (e) {
                try {
                    let graphQLErrors = (yield e.response.json()).errors;
                    throw new GraphQLError(e, graphQLErrors);
                }
                catch (e2) {
                    // If we fail to get a proper JSON graphql error, just throw the
                    // underlying exception without decoration
                    throw e;
                }
            }
        });
    }
    start(portConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.mockServerConfig)
                throw new Error('Server is already started');
            const path = portConfig ? `/start?port=${JSON.stringify(portConfig)}` : '/start';
            let mockServerConfig = yield this.requestFromStandalone(path, {
                method: 'POST',
                headers: new Headers({
                    'Content-Type': 'application/json'
                }),
                body: JSON.stringify(this.mockServerOptions)
            });
            // Also open a stream connection, for 2-way communication we might need later.
            this.mockServerStream = yield this.openStreamToMockServer(mockServerConfig);
            // We don't persist the config or resolve this promise until everything is set up
            this.mockServerConfig = mockServerConfig;
            // Load the schema on server start, so we can check for feature support
            this.mockServerSchema = (yield this.queryMockServer(introspection_query_1.introspectionQuery)).__schema;
        });
    }
    stop() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.mockServerConfig)
                return;
            this.mockServerStream.end();
            yield this.requestFromMockServer('/stop', {
                method: 'POST'
            });
            this.mockServerConfig = this.mockServerStream = undefined;
        });
    }
    typeHasField(typeName, fieldName) {
        const type = _.find(this.mockServerSchema.types, { name: typeName });
        if (!type)
            return false;
        return !!_.find(type.fields, { name: fieldName });
    }
    optionalField(typeName, fieldName) {
        return (this.typeHasField(typeName, fieldName))
            ? fieldName
            : '';
    }
    typeHasInputField(typeName, fieldName) {
        const type = _.find(this.mockServerSchema.types, { name: typeName });
        if (!type)
            return false;
        return !!_.find(type.inputFields, { name: fieldName });
    }
    enableDebug() {
        throw new Error("Client-side debug info not implemented.");
    }
    get url() {
        if (!this.mockServerConfig)
            throw new Error('Cannot get url before server is started');
        return this.mockServerConfig.mockRoot;
    }
    get port() {
        if (!this.mockServerConfig)
            throw new Error('Cannot get port before server is started');
        return this.mockServerConfig.port;
    }
    getMockedEndpoints() {
        return __awaiter(this, void 0, void 0, function* () {
            let result = yield this.queryMockServer(`query GetAllEndpointData {
                mockedEndpoints {
                    id,
                    ${this.optionalField('MockedEndpoint', 'explanation')}
                }
            }`);
            const mockedEndpoints = result.mockedEndpoints;
            return mockedEndpoints.map(e => new mocked_endpoint_client_1.MockedEndpointClient(e.id, e.explanation, this.getEndpointDataGetter(e.id)));
        });
    }
    getPendingEndpoints() {
        return __awaiter(this, void 0, void 0, function* () {
            let result = yield this.queryMockServer(`query GetPendingEndpointData {
                pendingEndpoints {
                    id,
                    explanation
                }
            }`);
            const pendingEndpoints = result.pendingEndpoints;
            return pendingEndpoints.map(e => new mocked_endpoint_client_1.MockedEndpointClient(e.id, e.explanation, this.getEndpointDataGetter(e.id)));
        });
    }
    on(event, callback) {
        if (event === 'tlsClientError')
            event = 'tls-client-error';
        const queryResultName = {
            'request-initiated': 'requestInitiated',
            request: 'requestReceived',
            response: 'responseCompleted',
            abort: 'requestAborted',
            'tls-client-error': 'failedTlsRequest',
            'client-error': 'failedClientRequest',
        }[event];
        // Ignore events unknown to either us or the server
        if (!queryResultName ||
            !this.typeHasField('Subscription', queryResultName))
            return Promise.resolve();
        const standaloneStreamServer = this.mockServerOptions.standaloneServerUrl.replace(/^http/, 'ws');
        const url = `${standaloneStreamServer}/server/${this.port}/subscription`;
        const client = new subscriptions_transport_ws_1.SubscriptionClient(url, {
            reconnect: true,
            reconnectionAttempts: 8,
            wsOptionArguments: [this.mockClientOptions]
        }, WebSocket);
        // Note the typeHasField checks - these are a quick hack for backward compatibility,
        // introspecting the server schema to avoid requesting fields that don't exist on old servers.
        const query = {
            'request-initiated': {
                operationName: 'OnRequestInitiated',
                query: `subscription OnRequestInitiated {
                    ${queryResultName} {
                        id,
                        protocol,
                        method,
                        url,
                        path,
                        hostname,

                        headers,
                        timingEvents,
                        httpVersion,
                        ${this.optionalField('InitiatedRequest', 'tags')}
                    }
                }`
            },
            request: {
                operationName: 'OnRequest',
                query: `subscription OnRequest {
                    ${queryResultName} {
                        id,
                        ${this.optionalField('Request', 'matchedRuleId')}
                        protocol,
                        method,
                        url,
                        path,
                        hostname,

                        headers,
                        body,
                        ${this.optionalField('Request', 'timingEvents')}
                        ${this.optionalField('Request', 'httpVersion')}
                        ${this.optionalField('Request', 'tags')}
                    }
                }`
            },
            response: {
                operationName: 'OnResponse',
                query: `subscription OnResponse {
                    ${queryResultName} {
                        id,
                        statusCode,
                        statusMessage,
                        headers,
                        body,
                        ${this.optionalField('Response', 'timingEvents')}
                        ${this.optionalField('Response', 'tags')}
                    }
                }`
            },
            abort: {
                operationName: 'OnAbort',
                query: `subscription OnAbort {
                    ${queryResultName} {
                        id,
                        protocol,
                        method,
                        url,
                        path,
                        hostname,

                        headers,
                        body,
                        ${this.optionalField('Response', 'timingEvents')}
                        ${this.optionalField('Response', 'tags')}
                    }
                }`
            },
            'tls-client-error': {
                operationName: 'OnTlsClientError',
                query: `subscription OnTlsClientError {
                    ${queryResultName} {
                        failureCause
                        hostname
                        remoteIpAddress
                        ${this.optionalField('TlsRequest', 'remotePort')}
                        ${this.optionalField('TlsRequest', 'tags')}
                        ${this.optionalField('TlsRequest', 'timingEvents')}
                    }
                }`
            },
            'client-error': {
                operationName: 'OnClientError',
                query: `subscription OnClientError {
                    ${queryResultName} {
                        errorCode
                        request {
                            id
                            timingEvents
                            tags
                            protocol
                            httpVersion
                            method
                            url
                            path
                            headers
                        }
                        response {
                            id
                            timingEvents
                            tags
                            statusCode
                            statusMessage
                            headers
                            body
                        }
                    }
                }`
            }
        }[event];
        client.request(query).subscribe({
            next: (value) => {
                if (value.data) {
                    const data = value.data[queryResultName];
                    if (event === 'client-error') {
                        data.request = _.mapValues(data.request, (v) => 
                        // Normalize missing values to undefined to match the local result
                        v === null ? undefined : v);
                        normalizeHttpMessage(event, data.request);
                        if (data.response) {
                            normalizeHttpMessage(event, data.response);
                        }
                        else {
                            data.response = 'aborted';
                        }
                    }
                    else {
                        normalizeHttpMessage(event, data);
                    }
                    callback(data);
                }
                else if (value.errors) {
                    console.error('Error in subscription', value.errors);
                }
            },
            error: (e) => this.debug && console.warn('Error in remote subscription:', e)
        });
        return new Promise((resolve, reject) => {
            client.onConnected(() => {
                if (this.debug)
                    console.log("Subscription connected");
                resolve();
            });
            client.onDisconnected(() => {
                if (this.debug)
                    console.warn("Subscription disconnected");
                reject();
            });
            client.onError((e) => {
                if (this.debug)
                    console.error("Subscription error", e);
            });
            client.onReconnecting(() => console.warn(`Reconnecting ${event} subscription`));
        });
    }
}
exports.default = MockttpClient;
//# sourceMappingURL=mockttp-client.js.map