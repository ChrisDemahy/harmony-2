/**
 * @module Mockttp
 */
import { TypedError } from 'typed-error';
import { MockedEndpoint } from "../types";
import { Mockttp, AbstractMockttp, MockttpOptions, PortRange } from "../mockttp";
import { RequestRuleData } from "../rules/requests/request-rule";
import { WebSocketRuleData } from '../rules/websockets/websocket-rule';
import { MockedEndpointClient } from "./mocked-endpoint-client";
export declare class ConnectionError extends TypedError {
}
declare global {
    interface Response {
    }
}
export declare class RequestError extends TypedError {
    response: Response;
    constructor(message: string, response: Response);
}
export declare class GraphQLError extends RequestError {
    errors: Array<{
        message: string;
    }>;
    constructor(response: Response, errors: Array<{
        message: string;
    }>);
}
declare type SubscribableEvent = 'request-initiated' | 'request' | 'response' | 'abort' | 'tls-client-error' | 'tlsClientError' | 'client-error';
export interface MockttpClientOptions extends MockttpOptions {
    /**
     * Options to include on all client requests, e.g. to add extra
     * headers for authentication.
     */
    client?: {
        headers?: {
            [key: string]: string;
        };
    };
}
/**
 * A Mockttp implementation, controlling a remote Mockttp standalone server.
 *
 * This starts servers by making requests to the remote standalone server, and exposes
 * methods to directly manage them.
 */
export default class MockttpClient extends AbstractMockttp implements Mockttp {
    private mockServerOptions;
    private mockClientOptions;
    private mockServerConfig;
    private mockServerStream;
    private mockServerSchema;
    constructor(options?: MockttpClientOptions);
    private requestFromStandalone;
    private openStreamToMockServer;
    private requestFromMockServer;
    private queryMockServer;
    start(portConfig?: number | PortRange): Promise<void>;
    stop(): Promise<void>;
    private typeHasField;
    private optionalField;
    private typeHasInputField;
    enableDebug(): void;
    reset: () => Promise<boolean>;
    get url(): string;
    get port(): number;
    addRequestRules: (...rules: RequestRuleData[]) => Promise<MockedEndpoint[]>;
    setRequestRules: (...rules: RequestRuleData[]) => Promise<MockedEndpoint[]>;
    addWebSocketRules: (...rules: WebSocketRuleData[]) => Promise<MockedEndpoint[]>;
    setWebSocketRules: (...rules: WebSocketRuleData[]) => Promise<MockedEndpoint[]>;
    private _addRules;
    private _addWsRules;
    getMockedEndpoints(): Promise<MockedEndpointClient[]>;
    getPendingEndpoints(): Promise<MockedEndpointClient[]>;
    private _addRule;
    on(event: SubscribableEvent, callback: (data: any) => void): Promise<void>;
    private getEndpointDataGetter;
}
export {};
