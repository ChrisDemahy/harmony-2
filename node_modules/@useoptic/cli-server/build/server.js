"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CliServer = exports.shutdownRequested = void 0;
const cli_config_1 = require("@useoptic/cli-config");
const events_1 = require("events");
const express_1 = __importDefault(require("express"));
const get_port_1 = __importDefault(require("get-port"));
const body_parser_1 = __importDefault(require("body-parser"));
const path_1 = __importDefault(require("path"));
const spec_router_1 = require("./routers/spec-router");
const ui_1 = require("@useoptic/ui");
const http_proxy_middleware_1 = require("http-proxy-middleware");
const analytics_1 = require("./analytics");
const cors_1 = __importDefault(require("cors"));
const sessions_1 = require("./sessions");
const optic_rc_1 = require("@useoptic/cli-config/build/opticrc/optic-rc");
const pJson = require('../package.json');
exports.shutdownRequested = 'cli-server:shutdown-requested';
class CliServer {
    constructor(config) {
        this.config = config;
        this.events = new events_1.EventEmitter();
        this.connections = [];
        this.corsOptions = {
            origin: [
                // this needs to be made exclusive in prod
                'http://localhost:4005',
                'https://app.o3c.info',
                'https://app.useoptic.com',
            ],
        };
    }
    addUiServer(app) {
        const resourceRoot = path_1.default.resolve(ui_1.basePath);
        const reactRoot = path_1.default.join(resourceRoot, 'build');
        const indexHtmlPath = path_1.default.join(reactRoot, 'index.html');
        app.use(express_1.default.static(reactRoot, {
            etag: false,
            maxAge: '5000',
        }));
        app.use(body_parser_1.default.json({ limit: '1mb' }));
        app.get('*', (req, res) => {
            res.sendFile(indexHtmlPath);
        });
    }
    async makeServer() {
        const app = express_1.default();
        app.use(cors_1.default(this.corsOptions));
        app.set('etag', false);
        const sessions = new sessions_1.SessionsManager();
        let user;
        const anonIdPromise = optic_rc_1.getOrCreateAnonId();
        app.get('/api/identity', async (req, res) => {
            res.json({ user, anonymousId: await anonIdPromise });
        });
        app.get('/api/daemon/status', async (req, res) => {
            res.json({ isRunning: true, version: pJson.version });
        });
        app.put('/api/identity', body_parser_1.default.json({ limit: '5kb' }), async (req, res) => {
            if (req.body.user) {
                user = req.body.user;
                res.status(202).json({});
            }
            else {
                res.sendStatus(400);
            }
        });
        app.post('/api/tracking/events', body_parser_1.default.json({ limit: '100kb' }), async (req, res) => {
            const events = req.body.events;
            analytics_1.track(...events);
            res.status(200).json({});
        });
        app.get('/api/tracking/events', async (req, res) => {
            function emit(data) {
                console.log('emit');
                res.write(`data: ${JSON.stringify(data)}\n\n`);
            }
            const headers = {
                'Content-Type': 'text/event-stream',
                Connection: 'keep-alive',
                'Cache-Control': 'no-cache',
            };
            res.writeHead(200, headers);
            analytics_1.analyticsEventEmitter.on('event', (event) => {
                emit({ type: 'message', data: event });
            });
            req.on('close', () => { });
        });
        // @REFACTOR sessionsRouter
        app.get('/api/sessions', (req, res) => {
            res.json({
                sessions,
            });
        });
        app.post('/api/sessions', body_parser_1.default.json({ limit: '5kb' }), async (req, res) => {
            const { path, taskConfig, captureId } = req.body;
            if (captureId && taskConfig) {
                const paths = await cli_config_1.getPathsRelativeToCwd(path);
                const { capturesPath } = paths;
                const capturesHelpers = new spec_router_1.CapturesHelpers(capturesPath);
                const now = new Date().toISOString();
                await capturesHelpers.updateCaptureState({
                    captureId,
                    status: 'started',
                    metadata: {
                        startedAt: now,
                        taskConfig,
                        lastInteraction: null,
                    },
                });
            }
            const session = await sessions.start(path);
            return res.json({
                session: {
                    id: session.id,
                    path: session.path,
                },
            });
        });
        // @REFACTOR adminRouter
        app.post('/admin-api/commands', body_parser_1.default.json({ limit: '1kb' }), async (req, res) => {
            const { body } = req;
            if (body.type === 'shutdown') {
                res.sendStatus(204);
                this.events.emit(exports.shutdownRequested);
                return;
            }
            res.sendStatus(400);
        });
        // specRouter
        const specRouter = spec_router_1.makeRouter(sessions);
        app.use('/api/specs/:specId', specRouter);
        // testing service proxy
        app.use('/api/testing', http_proxy_middleware_1.createProxyMiddleware({
            changeOrigin: true,
            followRedirects: true,
            target: this.config.cloudApiBaseUrl,
            pathRewrite(input, req) {
                return input.substring(req.baseUrl.length);
            },
        }));
        // ui
        this.addUiServer(app);
        return app;
    }
    async start() {
        const app = await this.makeServer();
        const port = await get_port_1.default({
            port: [34444],
        });
        return new Promise((resolve, reject) => {
            this.server = app.listen(port, () => {
                resolve({
                    port,
                });
            });
            this.server.on('connection', (connection) => {
                console.log(`adding connection`);
                this.connections.push(connection);
                connection.on('close', () => {
                    console.log(`removing connection`);
                    this.connections = this.connections.filter((c) => c !== connection);
                });
            });
        });
    }
    async stop() {
        if (this.server) {
            await new Promise((resolve) => {
                console.log(`server closing ${this.connections.length} open`);
                this.connections.forEach((connection) => {
                    console.log(`destroying existing connection`);
                    connection.end();
                    connection.destroy();
                });
                this.server.close((err) => {
                    console.log(`server closed`);
                    this.connections.forEach((connection) => {
                        console.log(`destroying existing connection`);
                        connection.end();
                        connection.destroy();
                    });
                    if (err) {
                        console.error(err);
                    }
                    resolve();
                });
            });
        }
    }
}
exports.CliServer = CliServer;
