"use strict";
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeRouter = void 0;
const express_1 = __importDefault(require("express"));
const body_parser_1 = __importDefault(require("body-parser"));
const stream_chain_1 = require("stream-chain");
const Stringer_1 = require("stream-json/Stringer");
const Disassembler_1 = require("stream-json/Disassembler");
const Replace_1 = require("stream-json/filters/Replace");
const stream_1 = require("stream");
const on_demand_initial_body_1 = require("../tasks/on-demand-initial-body");
function makeRouter(dependencies) {
    const router = express_1.default.Router({ mergeParams: true });
    router.put('/status', body_parser_1.default.json({ limit: '1kb' }), async (req, res) => {
        const { status } = req.body;
        if (status !== 'completed') {
            debugger;
            return res.sendStatus(400);
        }
        try {
            const { captureId } = req.params;
            const captureInfo = await req.optic.capturesHelpers.loadCaptureState(captureId);
            captureInfo.status = 'completed';
            await req.optic.capturesHelpers.updateCaptureState(captureInfo);
            res.sendStatus(204);
        }
        catch (e) {
            console.error(e);
            debugger;
            return res.sendStatus(400);
        }
    });
    router.get('/status', async (req, res) => {
        try {
            const { captureId } = req.params;
            const captureInfo = await req.optic.capturesHelpers.loadCaptureState(captureId);
            const captureSummary = await req.optic.capturesHelpers.loadCaptureSummary(captureId);
            res.json({
                status: captureInfo.status,
                diffsCount: captureSummary.diffsCount,
                interactionsCount: captureSummary.interactionsCount,
            });
        }
        catch (e) {
            return res.sendStatus(400);
        }
    });
    ////////////////////////////////////////////////////////////////////////////////
    router.post('/diffs', body_parser_1.default.json({ limit: '100mb' }), async (req, res) => {
        const { captureId } = req.params;
        const { ignoreRequests, events, additionalCommands, filters } = req.body;
        let diffId;
        try {
            diffId = await req.optic.session.diffCapture(captureId, events, filters);
        }
        catch (e) {
            return res.status(500).json({ message: e.message });
        }
        res.json({
            diffId,
            notificationsUrl: `${req.baseUrl}/diffs/${diffId}/notifications`,
        });
    });
    ////////////////////////////////////////////////////////////////////////////////
    router.post('/initial-bodies', body_parser_1.default.json({ limit: '100mb' }), async (req, res) => {
        const { captureId } = req.params;
        const { events, pathId, method } = req.body;
        const initialBodyGenerator = new on_demand_initial_body_1.OnDemandInitialBody({
            captureBaseDirectory: req.optic.paths.capturesPath,
            events: events,
            captureId,
            pathId,
            method,
        });
        const result = initialBodyGenerator.run();
        result.then((learnedBodies) => {
            res.json(learnedBodies);
        });
        result.catch((e) => {
            res.status(500).json({
                message: e.message,
            });
        });
    });
    ////////////////////////////////////////////////////////////////////////////////
    router.get('/diffs/:diffId/notifications', async (req, res) => {
        const { diffId } = req.params;
        const progress = req.optic.session.diffProgress(diffId);
        if (!progress) {
            return res.json(404);
        }
        const notifications = stream_chain_1.chain([
            progress,
            ({ type, data }) => {
                if (type === 'progress')
                    type = 'message';
                return [`data: ${JSON.stringify({ type, data })}\n\n`];
            },
        ]);
        const headers = {
            'Content-Type': 'text/event-stream',
            Connection: 'keep-alive',
            'Cache-Control': 'no-cache',
        };
        res.writeHead(200, headers);
        notifications.pipe(res);
    });
    ////////////////////////////////////////////////////////////////////////////////
    router.get('/diffs/:diffId/diffs', async (req, res) => {
        const { diffId } = req.params;
        const diffQueries = req.optic.session.diffQueries(diffId);
        if (!diffQueries) {
            return res.json(404);
        }
        let diffsStream = diffQueries.diffs();
        toJSONArray(diffsStream).pipe(res).type('application/json');
    });
    router.get('/diffs/:diffId/undocumented-urls', async (req, res) => {
        const { diffId } = req.params;
        const diffQueries = req.optic.session.diffQueries(diffId);
        if (!diffQueries) {
            return res.json(404);
        }
        let undocumentedUrls = diffQueries.undocumentedUrls();
        toJSONArray(undocumentedUrls, {
            base: { urls: [] },
            path: 'urls',
        })
            .pipe(res)
            .type('application/json');
    });
    router.get('/diffs/:diffId/stats', async (req, res) => {
        const { diffId } = req.params;
        const diffQueries = req.optic.session.diffQueries(diffId);
        if (!diffQueries) {
            return res.json(404);
        }
        let stats = await diffQueries.stats();
        res.json(stats);
    });
    ////////////////////////////////////////////////////////////////////////////////
    router.get('/interactions/:interactionPointer', async (req, res) => {
        const { captureId, interactionPointer } = req.params;
        const interactionPointerConverter = dependencies.interactionPointerConverterFactory({
            captureBaseDirectory: req.optic.paths.capturesPath,
            captureId,
        });
        const interaction = await interactionPointerConverter.fromPointer(interactionPointer);
        res.json({
            interaction,
        });
    });
    ////////////////////////////////////////////////////////////////////////////////
    return router;
}
exports.makeRouter = makeRouter;
function toJSONArray(itemsStream, wrap) {
    let tokenStream = stream_chain_1.chain([itemsStream, Disassembler_1.disassembler()]);
    if (!wrap)
        return tokenStream.pipe(Stringer_1.stringer({ makeArray: true }));
    let ARRAY_ITEM_MARKER = { name: 'array_insert_marker ' };
    let objectTokenStream = stream_chain_1.chain([
        stream_1.Readable.from([wrap.base]),
        Disassembler_1.disassembler(),
        Replace_1.replace({
            filter: wrap.path,
            once: true,
            allowEmptyReplacement: false,
            replacement: () => [
                { name: 'startArray' },
                ARRAY_ITEM_MARKER,
                { name: 'endArray' },
            ],
        }),
    ]);
    let outputGenerator = function (wrapTokenStream, arrayTokenStream, marker) {
        return __asyncGenerator(this, arguments, function* () {
            var e_1, _a, e_2, _b;
            try {
                for (var wrapTokenStream_1 = __asyncValues(wrapTokenStream), wrapTokenStream_1_1; wrapTokenStream_1_1 = yield __await(wrapTokenStream_1.next()), !wrapTokenStream_1_1.done;) {
                    let wrapToken = wrapTokenStream_1_1.value;
                    if (wrapToken === marker) {
                        try {
                            for (var arrayTokenStream_1 = (e_2 = void 0, __asyncValues(arrayTokenStream)), arrayTokenStream_1_1; arrayTokenStream_1_1 = yield __await(arrayTokenStream_1.next()), !arrayTokenStream_1_1.done;) {
                                let arrayToken = arrayTokenStream_1_1.value;
                                yield yield __await(arrayToken);
                            }
                        }
                        catch (e_2_1) { e_2 = { error: e_2_1 }; }
                        finally {
                            try {
                                if (arrayTokenStream_1_1 && !arrayTokenStream_1_1.done && (_b = arrayTokenStream_1.return)) yield __await(_b.call(arrayTokenStream_1));
                            }
                            finally { if (e_2) throw e_2.error; }
                        }
                    }
                    else {
                        yield yield __await(wrapToken);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (wrapTokenStream_1_1 && !wrapTokenStream_1_1.done && (_a = wrapTokenStream_1.return)) yield __await(_a.call(wrapTokenStream_1));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    };
    return stream_1.Readable.from(outputGenerator(objectTokenStream, tokenStream, ARRAY_ITEM_MARKER)).pipe(Stringer_1.stringer());
}
function toJSONObject() {
    return stream_chain_1.chain([Disassembler_1.disassembler(), Stringer_1.stringer({ makeArray: true })]);
}
