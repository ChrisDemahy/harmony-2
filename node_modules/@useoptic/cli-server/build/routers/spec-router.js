"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeRouter = exports.ExampleRequestsHelpers = exports.CapturesHelpers = exports.isValidCaptureState = void 0;
const cli_config_1 = require("@useoptic/cli-config");
const express_1 = __importDefault(require("express"));
const body_parser_1 = __importDefault(require("body-parser"));
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const lodash_sortby_1 = __importDefault(require("lodash.sortby"));
const cli_shared_1 = require("@useoptic/cli-shared");
const capture_router_1 = require("./capture-router");
const interaction_iterator_1 = require("@useoptic/cli-shared/build/captures/avro/file-system/interaction-iterator");
const ignore_file_interface_1 = require("@useoptic/cli-config/build/helpers/ignore-file-interface");
const patch_optic_config_1 = require("@useoptic/cli-config/build/helpers/patch-optic-config");
function isValidCaptureState(x) {
    return x.status === 'started' || x.status === 'completed';
}
exports.isValidCaptureState = isValidCaptureState;
const captureStateFileName = 'optic-capture-state.json';
class CapturesHelpers {
    constructor(basePath) {
        this.basePath = basePath;
    }
    async validateCaptureId(req, res, next) {
        const { captureId } = req.params;
        const captureDirectoryPath = this.captureDirectory(captureId);
        const exists = await fs_extra_1.default.pathExists(captureDirectoryPath);
        if (exists) {
            return next();
        }
        else {
            return res.sendStatus(404);
        }
    }
    async listCaptureIds() {
        const captureIds = await fs_extra_1.default.readdir(this.basePath);
        return captureIds;
    }
    async loadCaptureState(captureId) {
        const stateFilePath = this.stateFile(captureId);
        const stateFileExists = await fs_extra_1.default.pathExists(stateFilePath);
        if (!stateFileExists) {
            return {
                captureId,
                status: 'unknown',
            };
        }
        const state = await fs_extra_1.default.readJson(stateFilePath);
        return state;
    }
    async updateCaptureState(state) {
        await fs_extra_1.default.ensureDir(this.captureDirectory(state.captureId));
        const stateFilePath = this.stateFile(state.captureId);
        await fs_extra_1.default.writeJson(stateFilePath, state);
    }
    async listCapturesState() {
        const captureIds = await this.listCaptureIds();
        const promises = captureIds.map((captureId) => {
            return this.loadCaptureState(captureId);
        });
        const capturesState = await Promise.all(promises);
        return capturesState.filter((x) => x !== null);
    }
    async loadCaptureSummary(captureId) {
        const captureDirectory = this.captureDirectory(captureId);
        const files = await fs_extra_1.default.readdir(captureDirectory);
        const interactions = files.filter((x) => x.startsWith('interactions-'));
        const promises = interactions.map((x) => {
            return fs_extra_1.default.readJson(path_1.default.join(captureDirectory, x));
        });
        const summaries = await Promise.all(promises);
        const summary = summaries.reduce((acc, value) => {
            acc.diffsCount = acc.diffsCount + value.diffsCount;
            acc.interactionsCount = acc.interactionsCount + value.interactionsCount;
            return acc;
        }, { diffsCount: 0, interactionsCount: 0 });
        return summary;
    }
    stateFile(captureId) {
        return path_1.default.join(this.captureDirectory(captureId), captureStateFileName);
    }
    captureDirectory(captureId) {
        return path_1.default.join(this.basePath, captureId);
    }
}
exports.CapturesHelpers = CapturesHelpers;
class ExampleRequestsHelpers {
    constructor(basePath) {
        this.basePath = basePath;
    }
    exampleFile(requestId) {
        return path_1.default.join(this.basePath, requestId, 'examples.json');
    }
    async getExampleRequests(requestId) {
        const exampleFilePath = this.exampleFile(requestId);
        const currentFileContents = await (async () => {
            const exists = await fs_extra_1.default.pathExists(exampleFilePath);
            if (exists) {
                try {
                    const contents = await fs_extra_1.default.readJson(exampleFilePath);
                    return contents;
                }
                catch (e) {
                    return [];
                }
            }
            return [];
        })();
        return currentFileContents;
    }
    async saveExampleRequest(requestId, example) {
        const exampleFilePath = this.exampleFile(requestId);
        const currentFileContents = await this.getExampleRequests(requestId);
        currentFileContents.push(example);
        await fs_extra_1.default.ensureFile(exampleFilePath);
        await fs_extra_1.default.writeJson(exampleFilePath, currentFileContents, { spaces: 2 });
    }
}
exports.ExampleRequestsHelpers = ExampleRequestsHelpers;
function makeRouter(sessions) {
    function prepareEvents(events) {
        return `[
${events.map((x) => JSON.stringify(x)).join('\n,')}
]`;
    }
    async function ensureValidSpecId(req, res, next) {
        const { specId } = req.params;
        cli_shared_1.developerDebugLogger({ specId, sessions });
        const session = sessions.findById(specId);
        if (!session) {
            res.sendStatus(404);
            return;
        }
        try {
            const paths = await cli_config_1.getPathsRelativeToCwd(session.path);
            const { configPath, opticIgnorePath, capturesPath, exampleRequestsPath, } = paths;
            const config = await cli_config_1.readApiConfig(configPath);
            const ignoreHelper = new ignore_file_interface_1.IgnoreFileHelper(opticIgnorePath, configPath);
            const capturesHelpers = new CapturesHelpers(capturesPath);
            const exampleRequestsHelpers = new ExampleRequestsHelpers(exampleRequestsPath);
            req.optic = {
                config,
                paths,
                ignoreHelper,
                capturesHelpers,
                exampleRequestsHelpers,
                session,
            };
            next();
        }
        catch (e) {
            res.status(500).json({
                message: e.message,
            });
        }
    }
    const router = express_1.default.Router({ mergeParams: true });
    router.use(ensureValidSpecId);
    // events router
    router.get('/events', async (req, res) => {
        try {
            const events = await fs_extra_1.default.readJson(req.optic.paths.specStorePath);
            res.json(events);
        }
        catch (e) {
            res.json([]);
        }
    });
    router.put('/events', body_parser_1.default.json({ limit: '100mb' }), async (req, res) => {
        const events = req.body;
        await fs_extra_1.default.writeFile(req.optic.paths.specStorePath, prepareEvents(events));
        res.sendStatus(204);
    });
    // example requests router
    router.post('/example-requests/:requestId', body_parser_1.default.json({ limit: '100mb' }), async (req, res) => {
        const { requestId } = req.params;
        await req.optic.exampleRequestsHelpers.saveExampleRequest(requestId, req.body);
        res.sendStatus(204);
    });
    router.get('/example-requests/:requestId', async (req, res) => {
        const { requestId } = req.params;
        const currentFileContents = await req.optic.exampleRequestsHelpers.getExampleRequests(requestId);
        res.json({
            examples: currentFileContents,
        });
    });
    // captures router. cli picks captureId and writes to whatever persistence method and provides capture id to ui. api spec just shows spec?
    router.get('/captures', async (req, res) => {
        const captures = await req.optic.capturesHelpers.listCapturesState();
        const validCaptures = captures.filter((x) => isValidCaptureState(x));
        res.json({
            captures: lodash_sortby_1.default(validCaptures, (i) => i.metadata.startedAt)
                .reverse()
                .map((i) => ({
                captureId: i.captureId,
                status: i.status,
                lastUpdate: i.metadata.lastInteraction
                    ? i.metadata.lastInteraction.observedAt
                    : i.metadata.startedAt,
                links: [
                    {
                        rel: 'samples',
                        href: `${req.baseUrl}/captures/${i.captureId}/samples`,
                    },
                    {
                        rel: 'status',
                        href: `${req.baseUrl}/captures/${i.captureId}/status`,
                    },
                ],
            })),
        });
    });
    router.get('/config', async (req, res) => {
        const rules = await req.optic.ignoreHelper.getCurrentIgnoreRules();
        const configRaw = (await fs_extra_1.default.readFile(req.optic.paths.configPath)).toString();
        res.json({
            config: Object.assign(Object.assign({}, req.optic.config), { ignoreRequests: rules.allRules }),
            configRaw,
        });
    });
    router.post('/config/initial-task', body_parser_1.default.json({ limit: '100kb' }), async (req, res) => {
        const { task } = req.body;
        const { name, definition } = task;
        const newContents = patch_optic_config_1.patchInitialTaskOpticYaml(req.optic.config, definition, name);
        await fs_extra_1.default.writeFile(req.optic.paths.configPath, newContents);
        res.sendStatus(200);
    });
    router.post('/config/raw', body_parser_1.default.json({ limit: '100kb' }), async (req, res) => {
        const { raw } = req.body;
        await fs_extra_1.default.writeFile(req.optic.paths.configPath, raw);
        res.json({});
    });
    router.get('/ignores', async (req, res) => {
        const rules = await req.optic.ignoreHelper.getCurrentIgnoreRules();
        res.json({
            rules,
        });
    });
    router.patch('/ignores', body_parser_1.default.json({ limit: '100kb' }), async (req, res) => {
        const { rule } = req.body;
        if (typeof rule === 'string' && Boolean(cli_config_1.parseRule(rule))) {
            await req.optic.ignoreHelper.appendRule(rule);
            res.json({});
        }
        else {
            res.status(400).json({ message: 'Invalid ignore rule' });
        }
    });
    const captureRouter = capture_router_1.makeRouter({
        idGenerator: new cli_shared_1.DefaultIdGenerator(),
        interactionPointerConverterFactory: (config) => new interaction_iterator_1.LocalCaptureInteractionPointerConverter(config),
    });
    router.use('/captures/:captureId', captureRouter);
    router.get('/captures/:captureId/samples', async (req, res) => {
        const { captureId } = req.params;
        const loader = new cli_shared_1.FileSystemAvroCaptureLoader({
            captureId,
            captureBaseDirectory: req.optic.paths.capturesPath,
        });
        try {
            const filter = cli_config_1.parseIgnore(req.optic.config.ignoreRequests || []);
            const capture = await loader.loadWithFilter(filter);
            res.json({
                metadata: {},
                samples: capture.samples,
                links: [{ rel: 'next', href: '' }],
            });
        }
        catch (e) {
            console.error(e);
            res.sendStatus(500);
        }
    });
    router.get('/testing-credentials', async (req, res) => {
        const { paths } = req.optic;
        if (!(await fs_extra_1.default.pathExists(paths.testingConfigPath))) {
            return res.sendStatus(404);
        }
        try {
            const testingConfig = await cli_config_1.readTestingConfig(paths.testingConfigPath);
            return res.json({
                authToken: testingConfig.authToken,
            });
        }
        catch (e) {
            console.error(e);
            return res.sendStatus(500);
        }
    });
    return router;
}
exports.makeRouter = makeRouter;
