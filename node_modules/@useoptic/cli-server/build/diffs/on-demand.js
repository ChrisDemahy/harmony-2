"use strict";
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DiffQueries = exports.OnDemandDiff = void 0;
const events_1 = require("events");
const cli_scripts_1 = require("@useoptic/cli-scripts");
const diff_worker_1 = require("@useoptic/cli-shared/build/diffs/diff-worker");
const fs_extra_1 = __importDefault(require("fs-extra"));
const proper_lockfile_1 = __importDefault(require("proper-lockfile"));
const stream_1 = require("stream");
const stream_chain_1 = require("stream-chain");
const Parser_1 = require("stream-json/jsonl/Parser");
const ignore_file_interface_1 = require("@useoptic/cli-config/build/helpers/ignore-file-interface");
class OnDemandDiff {
    constructor(config) {
        this.events = new events_1.EventEmitter();
        this.finished = false;
        this.lastProgress = null;
        this.id = config.diffId;
        this.config = config;
    }
    async start() {
        var _a;
        const { config } = this;
        const ignoreHelper = new ignore_file_interface_1.IgnoreFileHelper(config.opticIgnorePath, config.configPath);
        const ignoreRules = await ignoreHelper.getCurrentIgnoreRules();
        const outputPaths = this.paths();
        await fs_extra_1.default.ensureDir(outputPaths.base);
        await Promise.all([
            config.events
                ? fs_extra_1.default.writeJson(outputPaths.events, config.events)
                : fs_extra_1.default.copy(config.specPath, outputPaths.events),
            fs_extra_1.default.writeJson(outputPaths.ignoreRequests, ignoreRules.allRules || []),
            fs_extra_1.default.writeJson(outputPaths.filters, config.endpoints || []),
            fs_extra_1.default.writeJson(outputPaths.additionalCommands, []),
        ]);
        const scriptConfig = {
            captureId: config.captureId,
            diffId: config.diffId,
            captureBaseDirectory: config.captureBaseDirectory,
            specFilePath: outputPaths.events,
            ignoreRequestsFilePath: outputPaths.ignoreRequests,
            additionalCommandsFilePath: outputPaths.additionalCommands,
            filtersFilePath: outputPaths.filters,
        };
        console.log(JSON.stringify(scriptConfig));
        const child = cli_scripts_1.runManagedScriptByName(process.env.OPTIC_RUST_DIFF_ENGINE === 'true'
            ? 'emit-diff-projections-rust'
            : 'emit-diff-projections', JSON.stringify(scriptConfig));
        const onMessage = (x) => {
            if (x.type && x.type === 'progress') {
                this.lastProgress = Object.assign({}, x.data);
            }
            this.events.emit(x.type, x.data);
        };
        const onError = (err) => {
            cleanup();
            this.events.emit('error', err);
        };
        const onExit = (code, signal) => {
            cleanup();
            if (code !== 0) {
                // @TODO: wonder how we'll ever find out about this happening.
                console.error(`Diff Worker exited with non-zero exit code ${code}`);
            }
            else {
                this.finished = true;
                this.events.emit('finish');
            }
        };
        function cleanup() {
            child.removeListener('message', onMessage);
            child.removeListener('error', onError);
            child.removeListener('exit', onExit);
        }
        child.on('message', onMessage);
        child.once('error', onError);
        child.once('exit', onExit);
        this.child = child;
        (_a = this.child.stderr) === null || _a === void 0 ? void 0 : _a.pipe(process.stderr);
        return new Promise((resolve, reject) => {
            function onErr(err) {
                cleanup();
                reject(err);
            }
            function onProgress(data) {
                cleanup();
                resolve();
            }
            function onFinish() {
                cleanup();
                resolve();
            }
            const cleanup = () => {
                this.events.removeListener('progress', onProgress);
                this.events.removeListener('error', onErr);
                this.events.removeListener('finish', onFinish);
            };
            this.events.once('progress', onProgress);
            this.events.once('error', onErr);
        });
    }
    latestProgress() {
        const lastProgress = this.lastProgress;
        return lastProgress ? Object.assign({}, lastProgress) : null;
    }
    paths() {
        return diff_worker_1.getDiffOutputPaths(this.config);
    }
    progress() {
        // NOTE: event emitters don't respect back pressure, so to make sure we don't overwhelm
        // downstream consumers, we stop observing progress events until a fully-buffered stream
        // drains again.
        const stream = new stream_1.PassThrough({ objectMode: true, highWaterMark: 4 });
        stream.write({ type: 'progress', data: this.latestProgress() });
        if (this.finished) {
            stream.end();
        }
        else {
            let resume = () => {
                let write = (progress) => {
                    if (!stream.write(progress)) {
                        stopListening();
                        stream.once('drain', resume);
                    }
                };
                let end = () => {
                    stopListening();
                    stream.end();
                };
                function onProgress(data) {
                    write({ type: 'progress', data });
                }
                function onErr(data) {
                    write({ type: 'error', data });
                    end();
                }
                function onFinish() {
                    end();
                }
                const stopListening = () => {
                    this.events.removeListener('progress', onProgress);
                    this.events.removeListener('error', onErr);
                    this.events.removeListener('finish', onFinish);
                };
                this.events.on('progress', onProgress);
                this.events.once('error', onErr);
                this.events.once('finish', onFinish);
            };
            resume();
        }
        return stream;
    }
    queries() {
        return new DiffQueries(this.paths());
    }
    async stop() {
        if (this.child) {
            this.child.kill('SIGTERM');
        }
    }
}
exports.OnDemandDiff = OnDemandDiff;
class DiffQueries {
    constructor(paths) {
        this.paths = paths;
    }
    diffs() {
        if (fs_extra_1.default.existsSync(this.paths.diffsStream)) {
            let diffs = stream_chain_1.chain([
                fs_extra_1.default.createReadStream(this.paths.diffsStream),
                Parser_1.parser(),
                (data) => [data.value],
            ]);
            return stream_1.Readable.from(this.normalizedDiffs(diffs));
        }
        else {
            let reading = lockedRead(this.paths.diffs);
            let itemsGenerator = jsonStreamGenerator(reading);
            return stream_1.Readable.from(itemsGenerator);
        }
    }
    undocumentedUrls() {
        if (fs_extra_1.default.existsSync(this.paths.diffsStream)) {
            let diffs = stream_chain_1.chain([
                fs_extra_1.default.createReadStream(this.paths.diffsStream),
                Parser_1.parser(),
                (data) => [data.value],
            ]);
            return stream_1.Readable.from(this.countUndocumentedUrls(diffs));
        }
        else {
            let reading = lockedRead(this.paths.undocumentedUrls);
            let itemsGenerator = jsonStreamGenerator(reading);
            return stream_1.Readable.from(itemsGenerator);
        }
    }
    stats() {
        return lockedRead(this.paths.stats);
    }
    normalizedDiffs(diffsStream) {
        return __asyncGenerator(this, arguments, function* normalizedDiffs_1() {
            var e_1, _a;
            let pointersByFingerprint = new Map();
            let diffs = [];
            try {
                for (var diffsStream_1 = __asyncValues(diffsStream), diffsStream_1_1; diffsStream_1_1 = yield __await(diffsStream_1.next()), !diffsStream_1_1.done;) {
                    let [diff, pointers, fingerprint] = diffsStream_1_1.value;
                    if (!fingerprint)
                        yield yield __await([diff, pointers]);
                    let existingPointers = pointersByFingerprint.get(fingerprint) || [];
                    if (existingPointers.length < 1) {
                        diffs.push([diff, fingerprint]);
                    }
                    pointersByFingerprint.set(fingerprint, existingPointers.concat(pointers));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (diffsStream_1_1 && !diffsStream_1_1.done && (_a = diffsStream_1.return)) yield __await(_a.call(diffsStream_1));
                }
                finally { if (e_1) throw e_1.error; }
            }
            for (let [diff, fingerprint] of diffs) {
                let pointers = pointersByFingerprint.get(fingerprint);
                if (!pointers)
                    throw new Error('unreachable');
                yield yield __await([diff, pointers]);
            }
        });
    }
    countUndocumentedUrls(diffsStream) {
        return __asyncGenerator(this, arguments, function* countUndocumentedUrls_1() {
            var e_2, _a;
            let countsByFingerprint = new Map();
            let undocumentedUrls = [];
            try {
                for (var diffsStream_2 = __asyncValues(diffsStream), diffsStream_2_1; diffsStream_2_1 = yield __await(diffsStream_2.next()), !diffsStream_2_1.done;) {
                    let [diff, _, fingerprint] = diffsStream_2_1.value;
                    let urlDiff = diff['UnmatchedRequestUrl'];
                    if (!urlDiff || !fingerprint)
                        continue;
                    let existingCount = countsByFingerprint.get(fingerprint) || 0;
                    if (existingCount < 1) {
                        let path = urlDiff.interactionTrail.path.find((interactionComponent) => interactionComponent.Url && interactionComponent.Url.path).Url.path;
                        let method = urlDiff.interactionTrail.path.find((interactionComponent) => interactionComponent.Method && interactionComponent.Method.method).Method.method;
                        undocumentedUrls.push({ path, method, fingerprint });
                    }
                    countsByFingerprint.set(fingerprint, existingCount + 1);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (diffsStream_2_1 && !diffsStream_2_1.done && (_a = diffsStream_2.return)) yield __await(_a.call(diffsStream_2));
                }
                finally { if (e_2) throw e_2.error; }
            }
            for (let { path, method, fingerprint } of undocumentedUrls) {
                let count = countsByFingerprint.get(fingerprint);
                if (!count)
                    throw new Error('unreachable');
                yield yield __await({ path, method, count });
            }
        });
    }
}
exports.DiffQueries = DiffQueries;
function jsonStreamGenerator(jsonPromise) {
    return __asyncGenerator(this, arguments, function* jsonStreamGenerator_1() {
        var e_3, _a;
        let json = yield __await(jsonPromise);
        if (Array.isArray(json)) {
            try {
                for (var json_1 = __asyncValues(json), json_1_1; json_1_1 = yield __await(json_1.next()), !json_1_1.done;) {
                    const item = json_1_1.value;
                    yield yield __await(item);
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (json_1_1 && !json_1_1.done && (_a = json_1.return)) yield __await(_a.call(json_1));
                }
                finally { if (e_3) throw e_3.error; }
            }
        }
        else {
            yield yield __await(json);
        }
    });
}
async function lockedRead(filePath) {
    await proper_lockfile_1.default.lock(filePath, {
        retries: { retries: 10 },
    });
    let json = await fs_extra_1.default.readJson(filePath);
    await proper_lockfile_1.default.unlock(filePath);
    return json;
}
