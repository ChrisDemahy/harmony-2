"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createDiff = void 0;
function createDiff(ctor, config) {
    return new ctor(config);
}
exports.createDiff = createDiff;
// @TODO: Figure out a reasonable way to type the streams, defining the objects that are yielded.
//        It will require the construction of the stream that's returned to have the required
//        Readable interface implemented. The tricky thing about that is that streams are constructed
//        in a lot of different possible ways. For really strong typing, every part of the pipeline
//        has to play ball. Perhaps a pragmatic first step is a PassThrough<T> that can be used to tack
//        on to an existing pipeline. But if we're casting types anyway, we could just do that during read?
//
//        Ideal would be:
// interface ResultStream<T> extends Readable<T> {}
//
//        Alternatively, we could use TypeScript's native support for AsyncIterable's and the flawless
//        interop with streams provided by Node. Issue with that is that tooling around AsyncIterables is
//        pretty meager.
// export async function* resultStreamGenerator<T>(
//   stream: Readable
// ): AsyncIterable<T> {
//   for await (let item of stream) {
//     yield item as T;
//   }
// }
