"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CaptureSaver = void 0;
const bottleneck_1 = __importDefault(require("bottleneck"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const avsc_1 = __importDefault(require("avsc"));
const index_1 = require("../../../index");
const index_2 = require("./index");
const index_3 = require("../index");
class CaptureSaver {
    constructor(config) {
        this.config = config;
        this.batcher = new bottleneck_1.default.Batcher({
            maxSize: 20,
            maxTime: 500,
        });
        this.tracking = new bottleneck_1.default({
            maxConcurrent: 10,
            minTime: 1,
        });
        this.batchCount = 0;
        this.interactionsReceivedCount = 0;
        this.interactionsSavedCount = 0;
    }
    async init() {
        const { captureId } = this.config;
        const outputDirectory = path_1.default.join(this.config.captureBaseDirectory, captureId);
        await fs_extra_1.default.ensureDir(outputDirectory);
        const agentId = '';
        const agentGroupId = '';
        this.batcher.on('batch', async (items) => {
            const batchId = this.batchCount.toString();
            index_1.developerDebugLogger(`handling batch id=${batchId} (${items.length} interactions)`);
            this.batchCount++;
            const groupingIdentifiers = {
                captureId,
                agentId,
                agentGroupId,
                batchId,
            };
            try {
                const promise = this.onBatch(groupingIdentifiers, batchId, items, outputDirectory);
                await this.tracking.schedule(() => promise);
                index_1.developerDebugLogger(`handled batch id=${batchId} (${items.length} interactions)`);
                this.interactionsSavedCount += items.length;
            }
            catch (e) {
                console.error(e);
            }
        });
    }
    async onBatch(groupingIdentifiers, batchId, items, outputDirectory) {
        const outputFile = path_1.default.join(outputDirectory, `${batchId}${index_2.captureFileSuffix}`);
        const output = {
            groupingIdentifiers,
            batchItems: items,
        };
        try {
            const encoder = avsc_1.default.createFileEncoder(outputFile, index_3.schema);
            await new Promise((resolve, reject) => {
                encoder.write(output, (err) => {
                    if (err) {
                        return reject(err);
                    }
                    resolve();
                });
            });
            await new Promise((resolve, reject) => {
                encoder.end(() => {
                    resolve();
                });
            });
        }
        catch (e) {
            console.error(e);
        }
    }
    async save(sample) {
        this.interactionsReceivedCount++;
        // don't await flush, just enqueue
        this.batcher.add(sample);
    }
    async cleanup() {
        index_1.developerDebugLogger('stopping capture saver');
        await new Promise((resolve, reject) => {
            const poll = () => {
                const interactionsReceivedCount = this.interactionsReceivedCount;
                const interactionsSavedCount = this.interactionsSavedCount;
                index_1.developerDebugLogger('waiting until interactionsReceivedCount matches interactionsSavedCount...', interactionsReceivedCount, interactionsSavedCount);
                if (interactionsSavedCount === interactionsReceivedCount) {
                    index_1.developerDebugLogger('done waiting until interactionsReceivedCount matches interactionsSavedCount', interactionsReceivedCount, interactionsSavedCount);
                    resolve();
                }
                else {
                    setTimeout(poll, 50);
                }
            };
            poll();
        });
        await this.tracking.stop({ dropWaitingJobs: false });
        index_1.developerDebugLogger('stopped capture saver');
    }
}
exports.CaptureSaver = CaptureSaver;
