"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CaptureLoader = void 0;
const index_1 = require("../../../index");
const index_2 = require("./index");
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const avsc_1 = __importDefault(require("avsc"));
const suffixOffset = -1 * index_2.captureFileSuffix.length;
class CaptureLoader {
    constructor(config) {
        this.config = config;
    }
    async listSortedCaptureFiles(captureId) {
        const sessionDirectory = path_1.default.join(this.config.captureBaseDirectory, captureId);
        const entries = await fs_extra_1.default.readdir(sessionDirectory);
        index_1.developerDebugLogger({ entries });
        const captureFiles = entries
            .filter((x) => x.endsWith(index_2.captureFileSuffix))
            .sort((a, b) => {
            const aBatchNumber = parseInt(a.slice(0, suffixOffset), 10);
            const bBatchNumber = parseInt(b.slice(0, suffixOffset), 10);
            return aBatchNumber - bBatchNumber;
        })
            .map((x) => path_1.default.join(sessionDirectory, x));
        index_1.developerDebugLogger({ captureFiles });
        return captureFiles;
    }
    async load() {
        const captureId = this.config.captureId;
        const captureFiles = await this.listSortedCaptureFiles(captureId);
        //@TODO: robustify by only reading n files at a time
        const entriesContents = await Promise.all(captureFiles.map((x) => {
            const decoder = avsc_1.default.createFileDecoder(x);
            return new Promise((resolve, reject) => {
                decoder.once('data', (contents) => {
                    resolve(contents);
                });
                decoder.once('error', (err) => reject(err));
            });
        }));
        const allSamples = entriesContents.reduce((acc, capture) => [
            ...acc,
            ...capture.batchItems,
        ], []);
        return {
            samples: allSamples,
        };
    }
    async loadWithFilter(filter) {
        const captureId = this.config.captureId;
        const captureFiles = await this.listSortedCaptureFiles(captureId);
        //@TODO: robustify by only reading n files at a time
        const entriesContents = await Promise.all(captureFiles.map((x) => {
            const decoder = avsc_1.default.createFileDecoder(x);
            return new Promise((resolve, reject) => {
                decoder.once('data', (contents) => {
                    resolve(contents);
                });
                decoder.once('error', (err) => reject(err));
            });
        }));
        const filteredSamples = entriesContents.reduce((acc, capture) => {
            const filteredEntrySamples = capture.batchItems.filter((x) => {
                return !filter.shouldIgnore(x.request.method, x.request.path);
            });
            return [...acc, ...filteredEntrySamples];
        }, []);
        return {
            samples: filteredSamples,
        };
    }
}
exports.CaptureLoader = CaptureLoader;
