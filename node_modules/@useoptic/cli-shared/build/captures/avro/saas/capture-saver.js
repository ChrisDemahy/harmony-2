"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CaptureSaver = void 0;
const bottleneck_1 = __importDefault(require("bottleneck"));
const index_1 = require("../../../index");
const index_2 = require("../index");
class CaptureSaver {
    constructor(config) {
        this.config = config;
        this.batcher = new bottleneck_1.default.Batcher({
            maxSize: 25,
            maxTime: 1000,
        });
        this.throttler = new bottleneck_1.default({
            maxConcurrent: 10,
            minTime: 1,
        });
        this.batchCount = 0;
        this.isStopping = false;
        this.saasClient = new index_1.SaasClient(config.baseUrl, config.launchTokenString);
    }
    async init() {
        this.batcher.on('batch', (items) => {
            this.batchCount++;
            const batchId = this.batchCount.toString();
            if (this.isStopping) {
                index_1.developerDebugLogger(`batch ${batchId} came too late`);
                return;
            }
            index_1.developerDebugLogger(`scheduled batch ${batchId}`);
            this.throttler.schedule(() => {
                index_1.developerDebugLogger(`saving batch ${batchId}`);
                return this.saveBatch(batchId, items)
                    .then(() => {
                    index_1.developerDebugLogger(`saved batch ${batchId}`);
                })
                    .catch((e) => {
                    index_1.developerDebugLogger(`error in batch ${batchId}`);
                    index_1.developerDebugLogger(e);
                });
            });
        });
    }
    async save(sample) {
        this.batcher.add(sample);
    }
    async saveBatch(batchId, items) {
        const { agentId, agentGroupId, captureId } = this.config;
        const { uploadUrl } = await this.saasClient.getInteractionsUploadUrl(agentId, batchId);
        const input = {
            groupingIdentifiers: {
                agentGroupId,
                captureId,
                agentId,
                batchId,
            },
            batchItems: items,
        };
        const bytes = index_2.serdes.toBuffer(input);
        return this.saasClient.uploadInteractions(uploadUrl, bytes);
    }
    async cleanup() {
        this.isStopping = true;
        index_1.developerDebugLogger('waiting for saving to finish...');
        try {
            await this.throttler.stop();
            await new Promise((resolve, reject) => {
                this.throttler.on('idle', resolve);
            });
        }
        catch (e) {
            index_1.developerDebugLogger(e);
        }
        index_1.developerDebugLogger('done waiting for saving to finish.');
    }
}
exports.CaptureSaver = CaptureSaver;
