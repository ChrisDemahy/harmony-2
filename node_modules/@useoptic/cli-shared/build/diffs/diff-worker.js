"use strict";
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DiffWorker = exports.getDiffOutputPaths = void 0;
const domain_utilities_1 = require("@useoptic/domain-utilities");
const cli_config_1 = require("@useoptic/cli-config");
const interaction_iterator_1 = require("../captures/avro/file-system/interaction-iterator");
const domain_1 = require("@useoptic/domain");
const fs_extra_1 = __importDefault(require("fs-extra"));
const bottleneck_1 = __importDefault(require("bottleneck"));
const path_1 = __importDefault(require("path"));
const proper_lockfile_1 = __importDefault(require("proper-lockfile"));
function getDiffOutputPaths(values) {
    const { captureBaseDirectory, captureId, diffId } = values;
    const base = path_1.default.join(captureBaseDirectory, captureId, 'diffs', diffId);
    const diffs = path_1.default.join(base, 'diffs.json');
    const diffsStream = path_1.default.join(base, 'diffs.jsonl');
    const stats = path_1.default.join(base, 'stats.json');
    const undocumentedUrls = path_1.default.join(base, 'undocumentedUrls.json');
    const events = path_1.default.join(base, 'events.json');
    const ignoreRequests = path_1.default.join(base, 'ignoreRequests.json');
    const filters = path_1.default.join(base, 'filters.json');
    const additionalCommands = path_1.default.join(base, 'additionalCommands.json');
    return {
        base,
        diffs,
        diffsStream,
        stats,
        undocumentedUrls,
        events,
        ignoreRequests,
        filters,
        additionalCommands,
    };
}
exports.getDiffOutputPaths = getDiffOutputPaths;
async function safeWriteJson(filePath, contents) {
    await fs_extra_1.default.ensureFile(filePath);
    await proper_lockfile_1.default.lock(filePath);
    await fs_extra_1.default.writeJson(filePath, contents);
    await proper_lockfile_1.default.unlock(filePath);
}
class DiffWorker {
    constructor(config) {
        this.config = config;
    }
    async run() {
        var e_1, _a;
        console.log('running');
        function notifyParentOfError(e) {
            if (process && process.send) {
                process.send({
                    type: 'error',
                    data: {
                        message: e.message,
                    },
                });
            }
            else {
                console.error(e);
            }
        }
        try {
            console.time('load inputs');
            const [ignoreRequests, events, additionalCommands, filters,] = await Promise.all([
                fs_extra_1.default.readJson(this.config.ignoreRequestsFilePath),
                fs_extra_1.default.readJson(this.config.specFilePath),
                fs_extra_1.default.readJson(this.config.additionalCommandsFilePath),
                fs_extra_1.default.readJson(this.config.filtersFilePath),
            ]);
            console.timeEnd('load inputs');
            console.time('build state');
            const batchId = 'bbb';
            const clientId = 'ccc'; //@TODO: should use real values
            const clientSessionId = 'sss'; //@TODO: should use real values
            const commandsContext = domain_1.RfcCommandContext(clientId, clientSessionId, batchId);
            const { rfcState, resolvers, } = domain_utilities_1.cachingResolversAndRfcStateFromEventsAndAdditionalCommandsSeq(events, commandsContext, domain_1.opticEngine.CommandSerialization.fromJs(additionalCommands));
            console.timeEnd('build state');
            const ignoredRequests = cli_config_1.parseIgnore(ignoreRequests);
            function filterIgnoredRequests(interaction) {
                return !ignoredRequests.shouldIgnore(interaction.request.method, interaction.request.path);
            }
            function filterByEndpoint(endpoint) {
                return function (interaction) {
                    const pathId = domain_1.ScalaJSHelpers.getOrUndefined(undocumentedUrlHelpers.tryResolvePathId(interaction.request.path));
                    return (endpoint.method === interaction.request.method &&
                        endpoint.pathId === pathId &&
                        !ignoredRequests.shouldIgnore(interaction.request.method, interaction.request.path));
                };
            }
            const interactionFilter = filters.length > 0
                ? filterByEndpoint(filters[0])
                : filterIgnoredRequests;
            const interactionIterator = interaction_iterator_1.CaptureInteractionIterator({
                captureId: this.config.captureId,
                captureBaseDirectory: this.config.captureBaseDirectory,
            }, interactionFilter);
            let diffs = domain_1.DiffHelpers.emptyInteractionPointersGroupedByDiff();
            let undocumentedUrls = domain_1.opticEngine.UndocumentedUrlHelpers.newCounter();
            const undocumentedUrlHelpers = new domain_1.opticEngine.com.useoptic.diff.helpers.UndocumentedUrlIncrementalHelpers(rfcState);
            let hasMoreInteractions = true;
            let diffedInteractionsCounter = BigInt(0);
            let skippedInteractionsCounter = BigInt(0);
            const batcher = new bottleneck_1.default.Batcher({
                maxSize: 100,
                maxTime: 100,
            });
            const diffOutputPaths = getDiffOutputPaths(this.config);
            const queue = new bottleneck_1.default({
                maxConcurrent: 1,
            });
            function notifyParent() {
                const progress = {
                    diffedInteractionsCounter: diffedInteractionsCounter.toString(),
                    skippedInteractionsCounter: skippedInteractionsCounter.toString(),
                    hasMoreInteractions,
                };
                if (process && process.send) {
                    process.send({
                        type: 'progress',
                        data: progress,
                    });
                }
                else {
                    console.log(progress);
                }
            }
            async function flush() {
                const c = diffedInteractionsCounter.toString();
                console.time(`flushing ${c}`);
                const outputDiff = safeWriteJson(diffOutputPaths.diffs, domain_1.opticEngine.DiffWithPointersJsonSerializer.toJs(diffs));
                const outputCount = safeWriteJson(diffOutputPaths.undocumentedUrls, domain_1.opticEngine.UrlCounterJsonSerializer.toFriendlyJs(undocumentedUrls));
                const outputStats = safeWriteJson(diffOutputPaths.stats, {
                    diffedInteractionsCounter: diffedInteractionsCounter.toString(),
                    skippedInteractionsCounter: skippedInteractionsCounter.toString(),
                    isDone: !hasMoreInteractions,
                });
                await Promise.all([outputDiff, outputCount, outputStats]);
                notifyParent();
                console.timeEnd(`flushing ${c}`);
            }
            batcher.on('batch', () => {
                console.log('scheduling batch flush');
                queue.schedule(() => {
                    console.log('executing batch flush');
                    return flush().catch((e) => {
                        notifyParentOfError(e);
                    });
                });
            });
            const interactionPointerConverter = new interaction_iterator_1.LocalCaptureInteractionPointerConverter({
                captureBaseDirectory: this.config.captureBaseDirectory,
                captureId: this.config.captureId,
            });
            await fs_extra_1.default.ensureDir(diffOutputPaths.base);
            await flush();
            try {
                for (var interactionIterator_1 = __asyncValues(interactionIterator), interactionIterator_1_1; interactionIterator_1_1 = await interactionIterator_1.next(), !interactionIterator_1_1.done;) {
                    const item = interactionIterator_1_1.value;
                    skippedInteractionsCounter = item.skippedInteractionsCounter;
                    diffedInteractionsCounter = item.diffedInteractionsCounter;
                    hasMoreInteractions = item.hasMoreInteractions;
                    if (!hasMoreInteractions) {
                        // @GOTCHA item.interaction.value should not be present when hasMoreInteractions is false
                        break;
                    }
                    if (!item.interaction) {
                        continue;
                    }
                    const { batchId, index } = item.interaction.context;
                    console.time(`serdes ${batchId} ${index}`);
                    const deserializedInteraction = domain_1.JsonHelper.fromInteraction(item.interaction.value);
                    console.timeEnd(`serdes ${batchId} ${index}`);
                    console.time(`diff ${batchId} ${index}`);
                    diffs = domain_1.DiffHelpers.groupInteractionPointerByDiffs(resolvers, rfcState, deserializedInteraction, interactionPointerConverter.toPointer(item.interaction.value, {
                        interactionIndex: index,
                        batchId,
                    }), diffs);
                    console.timeEnd(`diff ${batchId} ${index}`);
                    console.time(`count ${batchId} ${index}`);
                    undocumentedUrls = undocumentedUrlHelpers.countUndocumentedUrls(deserializedInteraction, undocumentedUrls);
                    console.timeEnd(`count ${batchId} ${index}`);
                    batcher.add(null);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (interactionIterator_1_1 && !interactionIterator_1_1.done && (_a = interactionIterator_1.return)) await _a.call(interactionIterator_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            hasMoreInteractions = false;
            batcher.add(null);
        }
        catch (e) {
            notifyParentOfError(e);
        }
    }
}
exports.DiffWorker = DiffWorker;
