"use strict";
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InitialBodiesWorker = exports.getInitialBodiesOutputPaths = void 0;
const domain_utilities_1 = require("@useoptic/domain-utilities");
const interaction_iterator_1 = require("../captures/avro/file-system/interaction-iterator");
const domain_1 = require("@useoptic/domain");
const fs_extra_1 = __importDefault(require("fs-extra"));
const bottleneck_1 = __importDefault(require("bottleneck"));
const path_1 = __importDefault(require("path"));
const LearnAPIHelper = domain_1.opticEngine.com.useoptic.diff.interactions.interpreters.LearnAPIHelper();
function getInitialBodiesOutputPaths(values) {
    const { captureBaseDirectory, captureId, pathId, method } = values;
    const base = path_1.default.join(captureBaseDirectory, captureId, 'initial-bodies', pathId, method);
    const events = path_1.default.join(base, 'events.json');
    const initialBodies = path_1.default.join(base, 'bodies.json');
    return {
        base,
        events,
        initialBodies,
    };
}
exports.getInitialBodiesOutputPaths = getInitialBodiesOutputPaths;
class InitialBodiesWorker {
    constructor(config) {
        this.config = config;
    }
    async run() {
        var e_1, _a;
        console.log('running');
        function notifyParentOfError(e) {
            if (process && process.send) {
                process.send({
                    type: 'error',
                    data: {
                        message: e.message,
                    },
                });
            }
            else {
                console.error(e);
            }
        }
        try {
            console.time('load inputs');
            const [events] = await Promise.all([
                fs_extra_1.default.readJson(this.config.specFilePath),
            ]);
            console.timeEnd('load inputs');
            console.time('build state');
            const batchId = 'bbb';
            const clientId = 'ccc'; //@TODO: should use real values
            const clientSessionId = 'sss'; //@TODO: should use real values
            const commandsContext = domain_1.RfcCommandContext(clientId, clientSessionId, batchId);
            const { rfcState, resolvers, } = domain_utilities_1.cachingResolversAndRfcStateFromEventsAndAdditionalCommandsSeq(events, commandsContext, domain_1.opticEngine.CommandSerialization.fromJs([]));
            console.timeEnd('build state');
            const undocumentedUrlHelpers = new domain_1.opticEngine.com.useoptic.diff.helpers.UndocumentedUrlIncrementalHelpers(rfcState);
            function filterByEndpoint(endpoint) {
                return function (interaction) {
                    const pathId = domain_1.ScalaJSHelpers.getOrUndefined(undocumentedUrlHelpers.tryResolvePathId(interaction.request.path));
                    return (endpoint.method === interaction.request.method &&
                        endpoint.pathId === pathId);
                };
            }
            const interactionFilter = filterByEndpoint({
                pathId: this.config.pathId,
                method: this.config.method,
            });
            const interactionIterator = interaction_iterator_1.CaptureInteractionIterator({
                captureId: this.config.captureId,
                captureBaseDirectory: this.config.captureBaseDirectory,
            }, interactionFilter);
            let hasMoreInteractions = true;
            const batcher = new bottleneck_1.default.Batcher({
                maxSize: 100,
                maxTime: 100,
            });
            const outputPaths = getInitialBodiesOutputPaths(this.config);
            const queue = new bottleneck_1.default({
                maxConcurrent: 1,
            });
            function notifyParent(results) {
                const progress = {
                    hasMoreInteractions,
                    results,
                };
                if (process && process.send) {
                    process.send({
                        type: 'progress',
                        data: progress,
                    });
                    if (!progress.hasMoreInteractions) {
                        setTimeout(() => process.exit(0), 100);
                    }
                }
                else {
                    console.log(progress);
                }
            }
            const { pathId, method } = this.config;
            const shapeBuilderMap = LearnAPIHelper.newShapeBuilderMap(pathId, method);
            async function flush() {
                const results = {
                    pathId,
                    method,
                    requests: domain_1.mapScala(shapeBuilderMap.requestRegions)((request) => ({
                        contentType: domain_1.getOrUndefined(request.contentType),
                        commands: domain_1.opticEngine.CommandSerialization.toJs(request.commands),
                        rootShapeId: request.rootShapeId,
                    })),
                    responses: domain_1.mapScala(shapeBuilderMap.responseRegions)((response) => ({
                        contentType: domain_1.getOrUndefined(response.contentType),
                        statusCode: response.statusCode,
                        commands: domain_1.opticEngine.CommandSerialization.toJs(response.commands),
                        rootShapeId: response.rootShapeId,
                    })),
                };
                notifyParent(results);
            }
            batcher.on('batch', () => {
                console.log('scheduling batch flush');
                queue.schedule(() => {
                    console.log('executing batch flush');
                    return flush().catch((e) => {
                        notifyParentOfError(e);
                    });
                });
            });
            await fs_extra_1.default.ensureDir(outputPaths.base);
            await flush();
            try {
                for (var interactionIterator_1 = __asyncValues(interactionIterator), interactionIterator_1_1; interactionIterator_1_1 = await interactionIterator_1.next(), !interactionIterator_1_1.done;) {
                    const item = interactionIterator_1_1.value;
                    hasMoreInteractions = item.hasMoreInteractions;
                    if (!hasMoreInteractions) {
                        // @GOTCHA item.interaction.value should not be present when hasMoreInteractions is false
                        break;
                    }
                    if (!item.interaction) {
                        continue;
                    }
                    const { batchId, index } = item.interaction.context;
                    console.time(`serdes ${batchId} ${index}`);
                    const deserializedInteraction = domain_1.JsonHelper.fromInteraction(item.interaction.value);
                    LearnAPIHelper.learnBody(deserializedInteraction, shapeBuilderMap);
                    batcher.add(null);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (interactionIterator_1_1 && !interactionIterator_1_1.done && (_a = interactionIterator_1.return)) await _a.call(interactionIterator_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            hasMoreInteractions = false;
            batcher.add(null);
        }
        catch (e) {
            notifyParentOfError(e);
        }
    }
}
exports.InitialBodiesWorker = InitialBodiesWorker;
