"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommandAndProxySessionManager = void 0;
const cli_config_1 = require("@useoptic/cli-config");
const command_session_1 = require("./command-session");
const httptoolkit_capturing_proxy_1 = require("./httptoolkit-capturing-proxy");
const index_1 = require("./index");
const url_1 = __importDefault(require("url"));
const build_query_string_parser_1 = require("./query/build-query-string-parser");
const await_up_1 = require("./tasks/await-up");
class CommandAndProxySessionManager {
    constructor(config, onStarted) {
        this.config = config;
        this.onStarted = onStarted;
    }
    async run(persistenceManager) {
        const commandSession = new command_session_1.CommandSession();
        const inboundProxy = new httptoolkit_capturing_proxy_1.HttpToolkitCapturingProxy();
        const servicePort = this.config.serviceConfig.port;
        const serviceHost = this.config.serviceConfig.host;
        const opticServiceConfig = {
            PORT: servicePort.toString(),
            OPTIC_API_PORT: servicePort.toString(),
            OPTIC_API_HOST: serviceHost.toString(),
            OPTIC_PROXY_PORT: this.config.proxyConfig.port.toString(),
        };
        await persistenceManager.init();
        inboundProxy.events.on('sample', (sample) => {
            index_1.userDebugLogger(`got sample ${sample.request.method} ${sample.request.path}`);
            persistenceManager.save(sample);
        });
        const target = url_1.default.format({
            hostname: serviceHost,
            port: servicePort,
            protocol: this.config.serviceConfig.protocol,
        });
        index_1.developerDebugLogger({ target });
        await inboundProxy.start({
            flags: {
                includeTextBody: process.env.OPTIC_ENABLE_CAPTURE_BODY === 'yes',
                includeJsonBody: process.env.OPTIC_ENABLE_CAPTURE_BODY === 'yes',
                includeShapeHash: true,
                includeQueryString: true,
            },
            host: this.config.proxyConfig.host,
            proxyTarget: process.env.OPTIC_ENABLE_TRANSPARENT_PROXY === 'yes'
                ? undefined
                : target,
            proxyPort: this.config.proxyConfig.port,
            queryParser: build_query_string_parser_1.buildQueryStringParser(),
        });
        index_1.userDebugLogger(`started inbound proxy on port ${this.config.proxyConfig.port}`);
        index_1.userDebugLogger(`All traffic should go through the inbound proxy on port ${this.config.proxyConfig.port} and it will be forwarded to ${this.config.serviceConfig.host}:${this.config.serviceConfig.port}.`);
        console.log(index_1.fromOptic(`Optic is observing requests made to ${this.config.proxyConfig.protocol}//${this.config.proxyConfig.host}:${this.config.proxyConfig.port}`));
        const promises = [];
        index_1.developerDebugLogger(this.config);
        if (this.config.command) {
            index_1.userDebugLogger(`Your command will be run with environment variable OPTIC_API_PORT=${servicePort}.`);
            index_1.userDebugLogger(`running command ${this.config.command}`);
            await commandSession.start({
                command: this.config.command,
                environmentVariables: Object.assign(Object.assign({}, process.env), opticServiceConfig),
            });
            if (this.onStarted) {
                // run test task for manual mode
                await await_up_1.awaitTaskUp(cli_config_1.Modes.Recommended, this.config);
                await this.onStarted();
                await commandSession.stop();
            }
            const commandStoppedPromise = new Promise((resolve) => {
                commandSession.events.on('stopped', ({ state }) => {
                    index_1.developerDebugLogger(`command session stopped (${state})`);
                    resolve();
                });
            });
            promises.push(commandStoppedPromise);
        }
        else {
            if (this.onStarted) {
                await await_up_1.awaitTaskUp(cli_config_1.Modes.Manual, this.config);
                await this.onStarted();
            }
        }
        const processInterruptedPromise = new Promise((resolve) => {
            process.on('SIGINT', () => {
                resolve();
            });
        });
        promises.push(processInterruptedPromise);
        index_1.developerDebugLogger(`waiting for command to complete or ^C...`);
        await Promise.race(promises);
        commandSession.stop();
        index_1.developerDebugLogger(`done waiting for command to complete or ^C`);
        index_1.developerDebugLogger(`waiting for proxy to stop...`);
        await inboundProxy.stop();
        index_1.developerDebugLogger(`done waiting for proxy to stop`);
        index_1.developerDebugLogger(`waiting for persistence manager to stop...`);
        await persistenceManager.cleanup();
        index_1.developerDebugLogger(`done waiting for persistence manager to stop`);
    }
}
exports.CommandAndProxySessionManager = CommandAndProxySessionManager;
