"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAssertionsFromProxyStartPromise = exports.getAssertionsFromCommandSession = exports.verifyRecommended = void 0;
const tslib_1 = require("tslib");
//@ts-ignore
const listr_1 = tslib_1.__importDefault(require("listr"));
const url_1 = tslib_1.__importDefault(require("url"));
const cli_shared_1 = require("@useoptic/cli-shared");
const colors_1 = tslib_1.__importDefault(require("colors"));
const wait_on_1 = tslib_1.__importDefault(require("wait-on"));
const assert_1 = tslib_1.__importDefault(require("assert"));
const build_query_string_parser_1 = require("@useoptic/cli-shared/build/query/build-query-string-parser");
const assertions_1 = require("./assertions");
async function verifyRecommended(task, startConfig) {
    const commandSessionPromise = getAssertionsFromCommandSession(task, startConfig);
    console.log(`\n\nYour ${colors_1.default.bold('command')}: ${colors_1.default.gray(startConfig.command)}`);
    const CommandCheckSteps = new listr_1.default([
        {
            title: `Starts a long running process (your API)`,
            task: async (cxt, task) => {
                const results = await commandSessionPromise;
                assert_1.default(results.longRunningAssertion.passed, 'Your command exited early');
            },
        },
        {
            title: `On the host Optic assigns it ${colors_1.default.bold('$HOST')} (current: ${colors_1.default.bold(startConfig.serviceConfig.host)})`,
            task: async () => {
                const results = await commandSessionPromise;
                assert_1.default(results.startOnHostAssertion.passed, `Your command did not start the API on ${colors_1.default.bold(startConfig.serviceConfig.host)}`);
            },
        },
        {
            title: `On the port Optic assigns it ${colors_1.default.bold('$PORT')} (current: ${colors_1.default.bold(startConfig.serviceConfig.port.toString())})`,
            task: async () => {
                const results = await commandSessionPromise;
                assert_1.default(results.startOnPortAssertion.passed, `Your command did not start the API on ${colors_1.default.bold('$PORT')} after 25 seconds`);
            },
        },
    ]);
    await new Promise((resolve) => {
        CommandCheckSteps.run().then(resolve).catch(resolve);
    });
    // const proxyStartPromise = getAssertionsFromProxyStartPromise(startConfig);
    console.log(`\n\nGiven this ${colors_1.default.bold('inboundUrl')}: ${colors_1.default.gray(task.inboundUrl)}`);
    const ProxyCheckSteps = new listr_1.default([
        {
            title: `Optic proxy is able to start its proxy here ${colors_1.default.bold(`${startConfig.proxyConfig.host}:${startConfig.proxyConfig.port.toString()}`)}`,
            task: async (cxt, task) => {
                const results = await commandSessionPromise;
                assert_1.default(results.proxyCanStartAtInboundUrl.passed, 'Optic could not start here: ' +
                    results.proxyCanStartAtInboundUrl.hostname);
            },
        },
    ]);
    await new Promise((resolve) => {
        ProxyCheckSteps.run().then(resolve).catch(resolve);
    });
    const assertions = Object.assign({}, (await commandSessionPromise));
    const failing = assertions_1.failingAssertions([
        assertions.longRunningAssertion,
        assertions.startOnHostAssertion,
        assertions.startOnPortAssertion,
        assertions.proxyCanStartAtInboundUrl,
    ]);
    return {
        assertions,
        failing,
        passedAll: failing.length === 0,
    };
}
exports.verifyRecommended = verifyRecommended;
async function getAssertionsFromCommandSession(task, startConfig) {
    const commandSession = new cli_shared_1.CommandSession();
    const serviceConfig = startConfig.serviceConfig;
    const servicePort = serviceConfig.port;
    const serviceHost = serviceConfig.host;
    const opticServiceConfig = {
        PORT: servicePort.toString(),
        OPTIC_API_PORT: servicePort.toString(),
        OPTIC_API_HOST: serviceHost.toString(),
    };
    const expected = `${serviceConfig.host}:${serviceConfig.port}`;
    const shouldNotTake = `${startConfig.proxyConfig.host}:${startConfig.proxyConfig.port}`;
    const inboundPortIsOpenAtStart = new Promise(async (resolve) => {
        wait_on_1.default({
            resources: [`tcp:${shouldNotTake}`],
            delay: 0,
            tcpTimeout: 500,
            timeout: 500,
        })
            .then(() => {
            resolve(false);
        }) //if service resolves we assume it's up.
            .catch(() => resolve(true));
    });
    await commandSession.start({
        command: startConfig.command,
        // @ts-ignore
        environmentVariables: Object.assign(Object.assign({}, process.env), opticServiceConfig),
    }, true);
    let status = 'running';
    let serviceRunning = false;
    let tookProxyPort = false;
    const commandStoppedPromise = new Promise((resolve) => {
        commandSession.events.on('stopped', ({ state }) => {
            status = state;
            resolve();
        });
    });
    const serviceRunningPromise = new Promise(async (resolve) => {
        wait_on_1.default({
            resources: [`tcp:${expected}`],
            delay: 0,
            tcpTimeout: 500,
            timeout: 25000,
        })
            .then(() => {
            serviceRunning = true;
            resolve(true);
        }) //if service resolves we assume it's up.
            .catch(() => resolve(false));
    });
    const wrongPortTaken = new Promise(async (resolve) => {
        wait_on_1.default({
            resources: [`tcp:${shouldNotTake}`],
            delay: 0,
            tcpTimeout: 500,
            timeout: 25000,
        })
            .then(() => {
            tookProxyPort = true;
            serviceRunning = false;
            resolve(true);
        }) //if service resolves we assume it's up.
            .catch(() => resolve(false));
    });
    await Promise.race([
        commandStoppedPromise,
        serviceRunningPromise,
        wrongPortTaken,
    ]);
    commandSession.stop();
    //assertions
    const startOnHostAssertion = {
        passed: serviceRunning || serviceHost === 'localhost',
        expectedHost: serviceConfig.host,
    };
    const startOnPortAssertion = {
        passed: serviceRunning,
        expectedPort: serviceConfig.port.toString(),
    };
    const longRunningAssertion = {
        passed: status === 'running',
        command: startConfig.command,
    };
    const proxyCanStartAtInboundUrl = {
        passed: inboundPortIsOpenAtStart && !tookProxyPort,
        hostname: shouldNotTake,
    };
    return {
        startOnHostAssertion,
        startOnPortAssertion,
        longRunningAssertion,
        proxyCanStartAtInboundUrl,
    };
}
exports.getAssertionsFromCommandSession = getAssertionsFromCommandSession;
async function getAssertionsFromProxyStartPromise(startConfig) {
    const proxyConfig = startConfig.proxyConfig;
    const proxyPort = proxyConfig.port;
    const proxyHost = proxyConfig.host;
    const serviceConfig = startConfig.serviceConfig;
    const servicePort = serviceConfig.port;
    const serviceHost = serviceConfig.host;
    const expected = `${proxyHost}:${proxyPort}`;
    const inboundProxy = new cli_shared_1.HttpToolkitCapturingProxy();
    const target = url_1.default.format({
        hostname: serviceHost,
        port: servicePort,
        protocol: serviceConfig.protocol,
    });
    await inboundProxy.start({
        flags: {
            includeTextBody: true,
            includeJsonBody: true,
            includeShapeHash: true,
            includeQueryString: true,
        },
        host: proxyConfig.host,
        proxyTarget: process.env.OPTIC_ENABLE_TRANSPARENT_PROXY === 'yes' ? undefined : target,
        proxyPort: proxyConfig.port,
        queryParser: build_query_string_parser_1.buildQueryStringParser(),
    });
    const proxyRunningPromise = await new Promise(async (resolve) => {
        wait_on_1.default({
            resources: [`tcp:${expected}`],
            delay: 0,
            tcpTimeout: 500,
            timeout: 15000,
        })
            .then(() => {
            resolve(true);
        }) //if service resolves we assume it's up.
            .catch(() => resolve(false));
    });
    await inboundProxy.stop();
    const proxyCanStartAtInboundUrl = {
        passed: proxyRunningPromise,
        hostname: expected,
    };
    return {
        proxyCanStartAtInboundUrl,
    };
}
exports.getAssertionsFromProxyStartPromise = getAssertionsFromProxyStartPromise;
