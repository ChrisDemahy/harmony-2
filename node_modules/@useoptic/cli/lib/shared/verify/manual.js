"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAssertionsFromTargetExistsPromise = exports.verifyManual = void 0;
const tslib_1 = require("tslib");
//@ts-ignore
const listr_1 = tslib_1.__importDefault(require("listr"));
//@ts-ignore
const colors_1 = tslib_1.__importDefault(require("colors"));
const wait_on_1 = tslib_1.__importDefault(require("wait-on"));
const assertions_1 = require("./assertions");
const assert_1 = tslib_1.__importDefault(require("assert"));
const recommended_1 = require("./recommended");
async function verifyManual(task, startConfig) {
    var _a;
    const proxyStartPromise = recommended_1.getAssertionsFromProxyStartPromise(startConfig);
    console.log(`\n\nGiven this ${colors_1.default.bold('inboundUrl')}: ${colors_1.default.gray(task.inboundUrl)}`);
    const ProxyCheckSteps = new listr_1.default([
        {
            title: `Optic proxy is able to start its proxy here ${colors_1.default.bold(`${startConfig.proxyConfig.host}:${startConfig.proxyConfig.port.toString()}`)}`,
            task: async (cxt, task) => {
                const results = await proxyStartPromise;
                assert_1.default(results.proxyCanStartAtInboundUrl.passed, 'Optic could not start here: ' +
                    results.proxyCanStartAtInboundUrl.hostname);
            },
        },
    ]);
    await new Promise((resolve) => {
        ProxyCheckSteps.run().then(resolve).catch(resolve);
    });
    ////////////////////////////////////////////////////////
    console.log(`\n\nGiven this ${colors_1.default.bold('targetUrl')}: ${colors_1.default.gray(task.targetUrl)}`);
    let isTargetResolvable;
    const TargetCheckSteps = new listr_1.default([
        {
            title: `Is resolvable from localhost`,
            enabled: () => !Boolean(task.command),
            task: async () => {
                const results = await getAssertionsFromTargetExistsPromise(startConfig);
                isTargetResolvable = results.proxyTargetUrlResolves;
                assert_1.default(results.proxyTargetUrlResolves.passed, 'hostname could not be resolved');
            },
        },
        {
            title: `Is resolvable after command ${colors_1.default.gray(((_a = task.command) === null || _a === void 0 ? void 0 : _a.toString()) || '')}`,
            enabled: () => Boolean(task.command),
            task: async () => {
                const commandSessionPromise = await recommended_1.getAssertionsFromCommandSession(task, startConfig);
                isTargetResolvable = {
                    passed: commandSessionPromise.proxyCanStartAtInboundUrl.passed,
                    targetHostname: commandSessionPromise.proxyCanStartAtInboundUrl.hostname,
                };
                assert_1.default(commandSessionPromise.proxyCanStartAtInboundUrl.passed, 'hostname could not be resolved');
            },
        },
    ]);
    await new Promise((resolve) => {
        TargetCheckSteps.run().then(resolve).catch(resolve);
    });
    const assertions = Object.assign(Object.assign({}, (await proxyStartPromise)), { isTargetResolvable: isTargetResolvable });
    const failing = assertions_1.failingAssertions(Object.values(assertions));
    return {
        assertions,
        failing,
        passedAll: failing.length === 0,
    };
}
exports.verifyManual = verifyManual;
async function getAssertionsFromTargetExistsPromise(startConfig) {
    const serviceConfig = startConfig.serviceConfig;
    const servicePort = serviceConfig.port;
    const serviceHost = serviceConfig.host;
    const target = `${serviceHost}:${servicePort}`;
    const targetRunningPromise = await new Promise(async (resolve) => {
        wait_on_1.default({
            resources: [`tcp:${target}`],
            delay: 0,
            tcpTimeout: 500,
            timeout: 10000,
        })
            .then(() => {
            resolve(true);
        }) //if service resolves we assume it's up.
            .catch(() => resolve(false));
    });
    const proxyTargetUrlResolves = {
        passed: targetRunningPromise,
        targetHostname: target,
    };
    return {
        proxyTargetUrlResolves,
    };
}
exports.getAssertionsFromTargetExistsPromise = getAssertionsFromTargetExistsPromise;
