"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.opticTaskToProps = exports.trackUserEvent = exports.getUser = void 0;
const tslib_1 = require("tslib");
/*
  @TODO:
  - Analytics should be abstracted with an interface: track(...)
  - There should be one implementation that does nothing
  - It should be easy to switch between implementations
  - We should not be spawning a new process every time we want to track something. We should be flushing events out of this process and another process can take care of them
 */
// @ts-ignore
const analytics_node_1 = tslib_1.__importDefault(require("analytics-node"));
const authentication_server_1 = require("./authentication-server");
const cli_client_1 = require("@useoptic/cli-client");
const cli_server_1 = require("@useoptic/cli-server");
const paths_1 = require("./paths");
const config_1 = require("../config");
const optic_rc_1 = require("@useoptic/cli-config/build/opticrc/optic-rc");
const packageJson = require('../../package.json');
const opticVersion = packageJson.version;
const token = 'RvYGmY1bZqlbMukS8pP9DPEifG6CEBEs';
const analytics = new analytics_node_1.default(token, {
    flushAt: 1,
});
const anonIdPromise = optic_rc_1.getOrCreateAnonId();
async function getUser() {
    return new Promise(async (resolve, reject) => {
        const credentials = await authentication_server_1.getCredentials();
        if (credentials) {
            const user = await authentication_server_1.getUserFromCredentials(credentials);
            analytics.identify({
                userId: await anonIdPromise,
                traits: { userId: user.sub, name: user.name, email: user.email },
            });
            resolve(user);
        }
        else {
            analytics.identify({
                userId: await anonIdPromise,
            });
        }
        resolve(null);
    });
}
exports.getUser = getUser;
async function trackUserEvent(event) {
    const daemonState = await cli_server_1.ensureDaemonStarted(paths_1.lockFilePath, config_1.Config.apiBaseUrl);
    const cliServerClient = new cli_client_1.Client(`http://localhost:${daemonState.port}/api`);
    await cliServerClient.postTrackingEvents([event]);
}
exports.trackUserEvent = trackUserEvent;
function opticTaskToProps(task, config) {
    if (config) {
        return {
            task,
            command: config.command,
            'serviceConfig.port': config.serviceConfig.port,
            'serviceConfig.host': config.serviceConfig.host,
            'serviceConfig.protocol': config.serviceConfig.protocol,
            'serviceConfig.basePath': config.serviceConfig.basePath,
            'proxyConfig.port': config.proxyConfig.port,
            'proxyConfig.host': config.proxyConfig.host,
            'proxyConfig.protocol': config.proxyConfig.protocol,
            'proxyConfig.basePath': config.proxyConfig.basePath,
        };
    }
    else {
        return { task };
    }
}
exports.opticTaskToProps = opticTaskToProps;
