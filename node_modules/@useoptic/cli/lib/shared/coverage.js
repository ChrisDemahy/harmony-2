"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createEndpointDescriptor = exports.printCoverage = void 0;
const tslib_1 = require("tslib");
const cli_shared_1 = require("@useoptic/cli-shared");
const cli_ux_1 = require("cli-ux");
const path_1 = tslib_1.__importDefault(require("path"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const domain_1 = require("@useoptic/domain");
const domain_utilities_1 = require("@useoptic/domain-utilities");
const CoverageConcerns = domain_1.opticEngine.com.useoptic.coverage;
const cli_table3_1 = tslib_1.__importDefault(require("cli-table3"));
const lodash_sortby_1 = tslib_1.__importDefault(require("lodash.sortby"));
const colors_1 = tslib_1.__importDefault(require("colors"));
const capture_saver_with_diffs_1 = require("@useoptic/cli-shared/build/captures/avro/file-system/capture-saver-with-diffs");
async function printCoverage(paths, taskName, captureId) {
    cli_ux_1.cli.action.start(cli_shared_1.fromOptic('Calculating Coverage...'));
    const input = await Promise.all([
        getSpecEndpoints(paths),
        getReport(paths, captureId),
    ]);
    const spec = input[0];
    const report = input[1];
    let table = new cli_table3_1.default({
        head: [
            colors_1.default.cyan.underline('Endpoint'),
            colors_1.default.cyan.underline('Coverage'),
        ],
    });
    let totalN = 0;
    let totalD = 0;
    let totalEndpointN = 0;
    let totalEndpointD = spec.length;
    spec.forEach((i) => {
        const endpointName = colors_1.default.bold(`${i.method.toUpperCase()} ${i.fullPath}`);
        const totalCount = report.coverageCounts.getCount(CoverageConcerns.TotalForPathAndMethod(i.pathId, i.method));
        if (totalCount > 0) {
            totalEndpointN = totalEndpointN + 1;
        }
        const responseStats = i.descriptor.responses.map((res) => {
            const count = report.coverageCounts.getCount(CoverageConcerns.TotalForResponse(res.responseId));
            return {
                statusCode: res.statusCode,
                responseId: res.responseId,
                count,
                copy: count > 0
                    ? colors_1.default.green(res.statusCode + ' ✔')
                    : colors_1.default.white.bgRed(res.statusCode),
                isCovered: count > 0,
            };
        });
        const requestStats = i.descriptor.requestBodies.map((req) => {
            const count = report.coverageCounts.getCount(CoverageConcerns.TotalForRequest(req.requestId));
            const contentType = req.requestBody.httpContentType || 'No Body';
            return {
                requestId: req.requestId,
                contentType: contentType,
                count,
                copy: count > 0
                    ? colors_1.default.green(contentType + ' ✔')
                    : colors_1.default.white.bgRed(contentType),
                isCovered: count > 0,
            };
        });
        const requests = `${colors_1.default.grey(`Requests (${requestStats.filter((i) => i.isCovered).length}/${requestStats.length}) ${requestStats.map((i) => i.copy).join('  ')}`)}`;
        const responses = `${colors_1.default.grey(`Responses (${responseStats.filter((i) => i.isCovered).length}/${responseStats.length}) ${responseStats.map((i) => i.copy).join('  ')}`)}`;
        const denominator = requestStats.length + responseStats.length;
        const numerator = requestStats.filter((i) => i.isCovered).length +
            responseStats.filter((i) => i.isCovered).length;
        totalN = totalN + numerator;
        totalD = totalD + denominator;
        const coverageCopy = (() => {
            const percent = (numerator / (denominator || 1)) * 100;
            if (numerator == denominator) {
                return colors_1.default.bold.green(`${percent}% Full Coverage ✔`);
            }
            else if (numerator < denominator && numerator > 0) {
                return colors_1.default.bold.yellow(`${percent}% Partial Coverage`);
            }
            return colors_1.default.bold.red(`0% No Coverage`);
        })();
        const coverage = colors_1.default.grey(`${coverageCopy}      ${totalCount} Examples`);
        // @ts-ignore
        table.push([
            `${endpointName}\n\n${coverage}`,
            `${requests}\n\n${responses}`,
        ]);
    });
    //print it out
    cli_ux_1.cli.action.stop();
    console.log(colors_1.default.bold(`\n\n API Coverage Report:`));
    console.log(table.toString());
    console.log('\n\n');
    const totals = report.coverageCounts.getCount(CoverageConcerns.TotalInteractions());
    console.log(colors_1.default.grey(`Based on ${totals} samples from task: ${colors_1.default.bold('start')}`));
    let resultTable = new cli_table3_1.default({
        head: [
            colors_1.default.grey.underline(''),
            colors_1.default.grey.underline('Observed'),
            colors_1.default.grey.underline('Expected'),
            colors_1.default.grey.underline('Percent Coverage'),
        ],
    });
    function colorProperly(full, partial, none) {
        return (string) => {
            if (full) {
                return string;
            }
            else if (none) {
                return makeRed(string);
            }
            else if (partial) {
                return makeYellow(string);
            }
            return string;
        };
    }
    const bodyCoverageColorer = colorProperly(totalN === totalD, totalN < totalD, totalN === 0);
    const endpointCoverageColorer = colorProperly(totalEndpointN === totalEndpointD, totalEndpointN < totalEndpointD, totalEndpointN === 0);
    resultTable.push(
    // @ts-ignore
    [
        'Documented Body Coverage',
        totalN.toString(),
        totalD.toString(),
        Math.round((totalN / (totalD || 1)) * 100).toString() + '%',
    ].map(bodyCoverageColorer), [
        'Documented Endpoint Coverage',
        totalEndpointN.toString(),
        totalEndpointD.toString(),
        Math.round((totalEndpointN / (totalEndpointD || 1)) * 100).toString() +
            '%',
    ].map(endpointCoverageColorer));
    console.log(resultTable.toString());
}
exports.printCoverage = printCoverage;
async function getSpecEndpoints(paths) {
    const events = await fs_extra_1.default.readJSON(paths.specStorePath);
    const { eventStore, rfcState, rfcService, rfcId } = domain_utilities_1.universeFromEvents(events);
    const queries = domain_1.Queries(eventStore, rfcService, rfcId);
    const cachedQueryResults = getCachedQueryResults(queries);
    const shapesResolvers = queries.shapesResolvers();
    const endpoints = queries.endpoints();
    const allEndpoints = endpoints.map((i) => (Object.assign(Object.assign({}, i), { fullPath: queries.absolutePath(i.pathId), descriptor: createEndpointDescriptor(i, cachedQueryResults) })));
    return lodash_sortby_1.default(allEndpoints, (i) => i.fullPath);
}
async function getReport(paths, captureId) {
    const capturesDirectory = path_1.default.join(paths.capturesPath, captureId);
    const entries = await fs_extra_1.default.readdir(capturesDirectory);
    const coverageFiles = entries
        .filter((x) => x.startsWith(capture_saver_with_diffs_1.coverageFilePrefix))
        .map((x) => path_1.default.join(capturesDirectory, x));
    const reportsToMerge = await Promise.all(coverageFiles.map(async (i) => {
        const coverageJSON = await fs_extra_1.default.readJSON(i);
        const asScala = domain_1.opticEngine.CoverageReportJsonDeserializer.fromJs(coverageJSON);
        return asScala;
    }));
    const report = domain_1.opticEngine.CoverageReportBuilder.emptyReport();
    //merge in all the reports
    reportsToMerge.forEach((i) => report.merge(i));
    // const finalReport = opticEngine.CoverageReportJsonSerializer.toJs(report);
    return report;
}
function getCachedQueryResults(queries) {
    const contributions = queries.contributions();
    const { requests, pathComponents, responses, requestParameters, } = queries.requestsState();
    const pathIdsByRequestId = queries.pathsWithRequests();
    const pathsById = pathComponents;
    // const absolutePaths = Object.keys(pathsById).map(pathId => ({ [pathId]: queries.absolutePath(pathId) })).reduce((acc, value) => Object.assign(acc, value), {})
    // console.log({ absolutePaths })
    const pathIdsWithRequests = new Set(Object.values(pathIdsByRequestId));
    const endpoints = queries.endpoints();
    const shapesState = queries.shapesState();
    const shapesResolvers = queries.shapesResolvers();
    const requestIdsByPathId = Object.entries(pathIdsByRequestId).reduce((acc, entry) => {
        const [requestId, pathId] = entry;
        //@ts-ignore
        const value = acc[pathId] || [];
        value.push(requestId);
        //@ts-ignore
        acc[pathId] = value;
        return acc;
    }, {});
    const cachedQueryResults = {
        contributions,
        requests,
        requestParameters,
        responses,
        responsesArray: Object.values(responses),
        pathIdsByRequestId,
        requestIdsByPathId,
        pathsById,
        endpoints,
        pathIdsWithRequests,
        shapesState,
        shapesResolvers,
    };
    return cachedQueryResults;
}
function createEndpointDescriptor({ method, pathId }, cachedQueryResults) {
    const { requests, pathsById, requestIdsByPathId, responsesArray, contributions, } = cachedQueryResults;
    const requestIdsOnPath = (requestIdsByPathId[pathId] || []).map((requestId) => requests[requestId]);
    const requestsOnPathAndMethod = requestIdsOnPath.filter((request) => request.requestDescriptor.httpMethod === method.toUpperCase());
    const requestBodies = requestsOnPathAndMethod.map(
    //@ts-ignore
    ({ requestId, requestDescriptor }) => {
        const requestBody = getNormalizedBodyDescriptor(requestDescriptor.bodyDescriptor);
        return {
            requestId,
            requestBody,
        };
    });
    const responsesForPathAndMethod = lodash_sortby_1.default(responsesArray
        .filter((response) => response.responseDescriptor.httpMethod === method.toUpperCase() &&
        response.responseDescriptor.pathId === pathId)
        .map(({ responseId, responseDescriptor }) => {
        const responseBody = getNormalizedBodyDescriptor(responseDescriptor.bodyDescriptor);
        return {
            responseId,
            responseBody,
            statusCode: responseDescriptor.httpStatusCode,
        };
    }), ['statusCode']);
    return {
        httpMethod: method,
        method,
        pathId,
        requestBodies,
        responses: responsesForPathAndMethod,
        isEmpty: requestBodies.length === 0 && responsesForPathAndMethod.length === 0,
    };
}
exports.createEndpointDescriptor = createEndpointDescriptor;
function getNormalizedBodyDescriptor(value) {
    if (value && value.ShapedBodyDescriptor) {
        return value.ShapedBodyDescriptor;
    }
    return {};
}
function makeYellow(string) {
    return colors_1.default.yellow(string);
}
function makeRed(string) {
    return colors_1.default.red(string);
}
