"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getUserFromCredentials = exports.getCredentials = exports.deleteCredentials = exports.setCredentials = exports.ensureCredentialsServerStarted = exports.tokenReceivedEvent = exports.loginBaseUrl = void 0;
const tslib_1 = require("tslib");
const cors_1 = tslib_1.__importDefault(require("cors"));
const body_parser_1 = tslib_1.__importDefault(require("body-parser"));
const express_1 = tslib_1.__importDefault(require("express"));
//@ts-ignore
const jwt_decode_1 = tslib_1.__importDefault(require("jwt-decode"));
const events_1 = require("events");
const get_port_1 = tslib_1.__importDefault(require("get-port"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const optic_rc_1 = require("@useoptic/cli-config/build/opticrc/optic-rc");
exports.loginBaseUrl = process.env.OPTIC_AUTH_UI_HOST || `https://app.useoptic.com`;
exports.tokenReceivedEvent = 'tokenReceived';
class CredentialsServer {
    constructor() {
        this.events = new events_1.EventEmitter();
    }
    async start(config) {
        const app = express_1.default();
        const whitelist = [
            exports.loginBaseUrl,
            'https://auth.useoptic.com',
            'https://app.o3c.info',
        ];
        const corsOptions = {
            origin: whitelist,
        };
        app.use(body_parser_1.default.json({ limit: '1mb' }));
        app.use(cors_1.default(corsOptions));
        const path = '/api/token';
        app.put(path, async (req, res) => {
            const { body } = req;
            const { idToken } = body;
            if (typeof idToken === 'string') {
                this.events.emit(exports.tokenReceivedEvent, idToken);
                return res.status(202).json({});
            }
            else {
                return res.status(400).json({});
            }
        });
        this.server = app.listen(config.port);
    }
    async stop() {
        await new Promise((resolve, reject) => {
            this.server.close((err) => {
                if (err) {
                    return reject(err);
                }
                resolve();
            });
        });
    }
}
async function ensureCredentialsServerStarted(overridePort = undefined) {
    const port = overridePort || (await get_port_1.default({ port: get_port_1.default.makeRange(3300, 3900) }));
    const server = new CredentialsServer();
    await server.start({ port });
    return {
        server,
        port,
    };
}
exports.ensureCredentialsServerStarted = ensureCredentialsServerStarted;
async function setCredentials(credentials) {
    const storage = await optic_rc_1.getCurrentStorage();
    const storeValue = Object.assign(Object.assign({}, (storage || optic_rc_1.defaultStorage())), { idToken: credentials.token });
    await fs_extra_1.default.ensureFile(optic_rc_1.opticrcPath);
    await fs_extra_1.default.writeFile(optic_rc_1.opticrcPath, JSON.stringify(storeValue));
}
exports.setCredentials = setCredentials;
async function deleteCredentials() {
    try {
        await fs_extra_1.default.remove(optic_rc_1.opticrcPath);
    }
    catch (e) { }
}
exports.deleteCredentials = deleteCredentials;
async function getCredentials() {
    try {
        const storage = await fs_extra_1.default.readJSON(optic_rc_1.opticrcPath);
        if (storage.idToken) {
            return { token: storage.idToken };
        }
        return null;
    }
    catch (e) {
        return null;
    }
}
exports.getCredentials = getCredentials;
async function getUserFromCredentials(credentials) {
    return jwt_decode_1.default(credentials.token);
}
exports.getUserFromCredentials = getUserFromCredentials;
