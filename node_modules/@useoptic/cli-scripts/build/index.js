"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runManagedScriptByName = exports.runManagedScript = exports.runScriptByName = exports.runStandaloneScript = exports.basePath = void 0;
const child_process_1 = __importDefault(require("child_process"));
const path_1 = __importDefault(require("path"));
exports.basePath = __dirname;
function runStandaloneScript(modulePath, ...args) {
    const child = child_process_1.default.fork(modulePath, args, { detached: true, stdio: 'ignore' });
    return child;
}
exports.runStandaloneScript = runStandaloneScript;
function runScriptByName(name, ...args) {
    return runStandaloneScript(path_1.default.join(exports.basePath, name), ...args);
}
exports.runScriptByName = runScriptByName;
function runManagedScript(modulePath, ...args) {
    //@GOTCHA: execArgv is inherited from the parent, so if you are using --inspect in the parent, the child will fail
    // instead, you can use --inspect=0 or --inspect=<some specific non-colliding port>
    const isDebuggingEnabled = process.env.OPTIC_DAEMON_ENABLE_DEBUGGING === 'yes';
    // const execArgv = isDebuggingEnabled ? ['--inspect=63694'] : []; // not in spawn
    const child = child_process_1.default.spawn(process.argv0, [modulePath, ...args], {
        windowsHide: true,
        // make sure stdout and stderr are consumed (by piping to process.stdout & process.stderr)
        // execution may block, otherwise.
        stdio: ['ignore', 'inherit', 'inherit', 'ipc'],
    });
    return child;
}
exports.runManagedScript = runManagedScript;
function runManagedScriptByName(name, ...args) {
    return runManagedScript(path_1.default.join(exports.basePath, name), ...args);
}
exports.runManagedScriptByName = runManagedScriptByName;
