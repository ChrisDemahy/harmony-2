"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JsonHttpClient = void 0;
const cross_fetch_1 = __importDefault(require("cross-fetch"));
class JsonHttpClient {
    static async verifyOkResponse(response) {
        const text = await response.text();
        if (!response.ok) {
            throw new Error(`expected a successful response. got ${response.status} ${response.statusText} \n${text}`);
        }
        return text;
    }
    static async handleJsonResponse(response) {
        if (response.ok) {
            if (response.status === 204) {
                return;
            }
            const json = await response.json();
            return json;
        }
        else {
            const text = await response.text();
            throw new Error(`${response.status} ${response.statusText} \n${text}`);
        }
    }
    static getJson(url, additionalHeaders = {}) {
        return cross_fetch_1.default(url, {
            method: 'GET',
            headers: Object.assign({ accept: 'application/json' }, additionalHeaders),
        }).then(JsonHttpClient.handleJsonResponse);
    }
    static getJsonWithoutHandlingResponse(url) {
        return cross_fetch_1.default(url, {
            method: 'GET',
            headers: {
                Accept: 'application/json',
            },
        });
    }
    static postJsonString(url, body, additionalHeaders = {}) {
        return cross_fetch_1.default(url, {
            method: 'POST',
            body,
            headers: Object.assign({ accept: 'application/json', 'content-type': 'application/json' }, additionalHeaders),
        }).then(JsonHttpClient.handleJsonResponse);
    }
    static postJson(url, body, additionalHeaders = {}) {
        return JsonHttpClient.postJsonString(url, JSON.stringify(body), additionalHeaders);
    }
    static patchJsonString(url, body, additionalHeaders = {}) {
        return cross_fetch_1.default(url, {
            method: 'PATCH',
            body,
            headers: Object.assign({ accept: 'application/json', 'content-type': 'application/json' }, additionalHeaders),
        }).then(JsonHttpClient.handleJsonResponse);
    }
    static patchJson(url, body, additionalHeaders = {}) {
        return JsonHttpClient.patchJsonString(url, JSON.stringify(body), additionalHeaders);
    }
    static postJsonWithoutBody(url, additionalHeaders = {}) {
        return cross_fetch_1.default(url, {
            method: 'POST',
            headers: Object.assign({ accept: 'application/json' }, additionalHeaders),
        }).then(JsonHttpClient.handleJsonResponse);
    }
    static getJsonAsText(url) {
        return cross_fetch_1.default(url, {
            headers: {
                accept: 'application/json',
            },
        }).then(JsonHttpClient.verifyOkResponse);
    }
    static putJson(url, body, additionalHeaders = {}) {
        return JsonHttpClient.putJsonString(url, JSON.stringify(body), additionalHeaders);
    }
    static putJsonString(url, body, additionalHeaders = {}) {
        return cross_fetch_1.default(url, {
            method: 'PUT',
            body: body,
            headers: Object.assign({ accept: 'application/json', 'content-type': 'application/json' }, additionalHeaders),
        }).then(JsonHttpClient.handleJsonResponse);
    }
    static putBytes(url, body, additionalHeaders = {}) {
        return cross_fetch_1.default(url, {
            method: 'PUT',
            body,
            headers: Object.assign({ 'content-length': body.length.toString() }, additionalHeaders),
        }).then(JsonHttpClient.verifyOkResponse);
    }
}
exports.JsonHttpClient = JsonHttpClient;
