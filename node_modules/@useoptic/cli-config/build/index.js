"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseRule = exports.parseIgnore = exports.Modes = exports.createFileTree = exports.getPathsRelativeToCwd = exports.pathsFromCwd = exports.getPathsRelativeToConfig = exports.TaskToStartConfig = exports.isManualTask = exports.isRecommendedTask = exports.isTestTask = exports.RunsWithTaskNotFoundError = exports.TaskNotFoundError = exports.TargetPortUnavailableError = exports.CommandExecutionFailure = exports.OpticConfigurationLocationFailure = exports.InvalidOpticConfigurationSyntaxError = exports.readTestingConfig = exports.readApiConfig = void 0;
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const url_1 = __importDefault(require("url"));
const js_yaml_1 = __importDefault(require("js-yaml"));
const get_port_1 = __importDefault(require("get-port"));
const find_up_1 = __importDefault(require("find-up"));
const ignore_parser_1 = require("./helpers/ignore-parser");
Object.defineProperty(exports, "parseRule", { enumerable: true, get: function () { return ignore_parser_1.parseRule; } });
Object.defineProperty(exports, "parseIgnore", { enumerable: true, get: function () { return ignore_parser_1.parseIgnore; } });
const deprecations_1 = __importStar(require("./deprecations"));
const default_ignore_rules_1 = require("./helpers/default-ignore-rules");
var deprecations_2 = require("./deprecations");
Object.defineProperty(exports, "deprecationLogger", { enumerable: true, get: function () { return deprecations_2.deprecationLogger; } });
async function readApiConfig(configPath) {
    const rawFile = await fs_extra_1.default.readFile(configPath);
    let parsed = null;
    try {
        // @ts-ignore
        return (parsed = js_yaml_1.default.safeLoad(rawFile.toString()));
    }
    catch (e) {
        throw new InvalidOpticConfigurationSyntaxError('`optic.yml` will not parse. Make sure it is valid YAML.');
    }
}
exports.readApiConfig = readApiConfig;
async function readTestingConfig(testingConfigPath) {
    const parsed = await fs_extra_1.default.readJSON(testingConfigPath);
    // TODO: validate shape?
    return parsed;
}
exports.readTestingConfig = readTestingConfig;
class InvalidOpticConfigurationSyntaxError extends Error {
}
exports.InvalidOpticConfigurationSyntaxError = InvalidOpticConfigurationSyntaxError;
class OpticConfigurationLocationFailure extends Error {
}
exports.OpticConfigurationLocationFailure = OpticConfigurationLocationFailure;
class CommandExecutionFailure extends Error {
}
exports.CommandExecutionFailure = CommandExecutionFailure;
class TargetPortUnavailableError extends Error {
}
exports.TargetPortUnavailableError = TargetPortUnavailableError;
class TaskNotFoundError extends Error {
}
exports.TaskNotFoundError = TaskNotFoundError;
class RunsWithTaskNotFoundError extends Error {
}
exports.RunsWithTaskNotFoundError = RunsWithTaskNotFoundError;
function randomLowerBound() {
    const max = 3500;
    const min = 3300;
    return Math.floor(Math.random() * (max - min + 1)) + min;
}
function isTestTask(aliasedTask) {
    return Boolean(aliasedTask.useTask && aliasedTask.command);
}
exports.isTestTask = isTestTask;
function isRecommendedTask(aliasedTask) {
    return Boolean(aliasedTask.command && (aliasedTask.inboundUrl || aliasedTask.baseUrl));
}
exports.isRecommendedTask = isRecommendedTask;
function isManualTask(aliasedTask) {
    return Boolean((aliasedTask.inboundUrl || aliasedTask.baseUrl) && aliasedTask.targetUrl);
}
exports.isManualTask = isManualTask;
async function TaskToStartConfig(aliasedTask) {
    const task = normalizeTask(aliasedTask);
    const baseUrl = url_1.default.parse(task.baseUrl);
    const targetUrl = (task.targetUrl && url_1.default.parse(task.targetUrl)) ||
        (task.proxy && url_1.default.parse(task.proxy)); // TODO: add deprecation warning
    if (task.proxy) {
        deprecations_1.warnDeprecation(deprecations_1.default.taskProxyField);
    }
    const serviceProtocol = (targetUrl && targetUrl.protocol) || baseUrl.protocol || 'http:';
    const serviceConfig = {
        host: (targetUrl && targetUrl.hostname) || baseUrl.hostname || 'localhost',
        protocol: serviceProtocol,
        port: targetUrl && targetUrl.port
            ? parseInt(targetUrl.port) // use target port if available
            : targetUrl
                ? serviceProtocol === 'http:' // assume standard ports for targets without explicit ports
                    ? 80
                    : 443
                : await get_port_1.default({ port: get_port_1.default.makeRange(randomLowerBound(), 3900) }),
        basePath: (targetUrl && targetUrl.path) || baseUrl.path || '/',
    };
    const proxyProtocol = baseUrl.protocol || 'http:';
    const proxyConfig = {
        host: baseUrl.hostname || 'localhost',
        protocol: proxyProtocol,
        port: baseUrl.port
            ? parseInt(baseUrl.port) // use base url port if explicitly set
            : proxyProtocol === 'http:' // assume standard port for base url without explicit port
                ? 80
                : 443,
        basePath: serviceConfig.basePath,
    };
    return {
        command: task.command,
        serviceConfig,
        proxyConfig,
    };
}
exports.TaskToStartConfig = TaskToStartConfig;
function normalizeTask(aliased) {
    const baseUrl = aliased.baseUrl || aliased.inboundUrl;
    if (!baseUrl && !aliased.useTask)
        throw new Error('Task definition must have baseUrl (aliases: inboundUrl)');
    if (aliased.useTask && (baseUrl || aliased.targetUrl)) {
        throw new Error('Task definitions with useTask should not include an inboundUrl or targetUrl ');
    }
    return Object.assign(Object.assign({}, aliased), { baseUrl });
}
async function getPathsRelativeToConfig() {
    const configPath = await find_up_1.default('optic.yml', { type: 'file' });
    if (configPath) {
        const configParentDirectory = path_1.default.resolve(configPath, '../');
        return await getPathsRelativeToCwd(configParentDirectory);
    }
    throw new OpticConfigurationLocationFailure(`expected to find an optic.yml file`);
}
exports.getPathsRelativeToConfig = getPathsRelativeToConfig;
function pathsFromCwd(cwd) {
    const configPath = path_1.default.join(cwd, 'optic.yml');
    const basePath = path_1.default.join(cwd, '.optic');
    const capturesPath = path_1.default.join(basePath, 'captures');
    const gitignorePath = path_1.default.join(basePath, '.gitignore');
    const opticIgnorePath = path_1.default.join(basePath, 'ignore');
    const specStorePath = path_1.default.join(basePath, 'api', 'specification.json');
    const exampleRequestsPath = path_1.default.join(basePath, 'api', 'example-requests');
    const testingConfigPath = path_1.default.join(basePath, 'testing.json');
    return {
        cwd,
        configPath,
        basePath,
        capturesPath,
        gitignorePath,
        opticIgnorePath,
        specStorePath,
        exampleRequestsPath,
        testingConfigPath,
    };
}
exports.pathsFromCwd = pathsFromCwd;
async function getPathsRelativeToCwd(cwd) {
    const pathMapping = pathsFromCwd(cwd);
    const { capturesPath, exampleRequestsPath } = pathMapping;
    await fs_extra_1.default.ensureDir(capturesPath);
    await fs_extra_1.default.ensureDir(exampleRequestsPath);
    return pathMapping;
}
exports.getPathsRelativeToCwd = getPathsRelativeToCwd;
async function createFileTree(config, basePath) {
    const { specStorePath, configPath, gitignorePath, opticIgnorePath, capturesPath, } = await getPathsRelativeToCwd(basePath);
    const files = [
        {
            path: gitignorePath,
            contents: `
captures/
`,
        },
        {
            path: opticIgnorePath,
            contents: default_ignore_rules_1.defaultIgnoreFile,
        },
        {
            path: specStorePath,
            contents: JSON.stringify([]),
        },
    ];
    if (config) {
        files.push({
            path: configPath,
            contents: config,
        });
    }
    await Promise.all(files.map(async (file) => {
        await fs_extra_1.default.ensureFile(file.path);
        await fs_extra_1.default.writeFile(file.path, file.contents);
    }));
    await fs_extra_1.default.ensureDir(capturesPath);
    return {
        configPath,
        basePath,
        capturesPath,
    };
}
exports.createFileTree = createFileTree;
var Modes;
(function (Modes) {
    Modes["Recommended"] = "Recommended";
    Modes["Manual"] = "Manual";
    Modes["Test"] = "Test";
})(Modes = exports.Modes || (exports.Modes = {}));
