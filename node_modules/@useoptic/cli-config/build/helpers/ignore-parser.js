"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseRule = exports.allowedMethods = exports.parseIgnore = void 0;
const path_to_regexp_1 = __importDefault(require("path-to-regexp"));
function parseIgnore(ignores) {
    const rules = ignores.map(parseRule).filter(notEmpty);
    return {
        rules,
        //expects uppercase methods
        shouldIgnore: (method, url) => {
            return !!rules.find((i) => i.shouldIgnore(method, url));
        },
    };
}
exports.parseIgnore = parseIgnore;
function notEmpty(value) {
    return value !== null && value !== undefined;
}
exports.allowedMethods = [
    'GET',
    'HEAD',
    'POST',
    'PUT',
    'DELETE',
    'CONNECT',
    'OPTIONS',
    'TRACE',
    'PATCH',
];
function parseRule(userInput) {
    const array = userInput.split(/[ ,]+/);
    if (array.length === 0 || userInput.length === 0) {
        return;
    }
    let methods = [];
    const pathInput = array.splice(array.length - 1)[0];
    const methodArray = array;
    if (methodArray.length === 0) {
        methods = exports.allowedMethods;
    }
    else {
        methods = methodArray
            .map((i) => i.toUpperCase())
            .filter((i) => exports.allowedMethods.includes(i));
    }
    const regex = path_to_regexp_1.default(pathInput);
    const shouldIgnore = (method, url) => methods.includes(method) && regex.exec(url) !== null;
    return {
        methods,
        path: pathInput,
        regex,
        shouldIgnore,
    };
}
exports.parseRule = parseRule;
